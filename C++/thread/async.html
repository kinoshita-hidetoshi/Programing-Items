<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="kinoshita hidetoshi (木下 英俊)">
  <meta name="description" content="木下英俊が自身のためにプログラムメモを残すことを目的に作成したページです。">
  <meta name="keywords" content="">
  <!-- キャッシュ無効化 -->
  <meta http-equiv="Cache-Control" content="no-cache">
  
  <!-- タイトル -->
  <title>std::async | Programming Items</title>
  
  <!-- ファビコン -->
  <link rel="shortcut icon" href="../../favicon.ico">
  
  <!-- CSS -->
  <link href="https://unpkg.com/ress/dist/ress.min.css" rel="stylesheet">
  <link rel="stylesheet" href="../../design.css" type="text/css">
	
  <!-- Start for 'google-code-prettify' -->
  <link href="../../prettify/styles/desert.css" rel="stylesheet" type="text/css">
  <script src="../../prettify/prettify.js" type="text/javascript"></script>
  <!-- End for 'google-code-prettify' -->
    
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-V2DZQK54C2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'G-V2DZQK54C2');
  </script>
  <!-- Global site tag (gtag.js) - Google Analytics -->

  <style type="text/css">
    .auto-style7 {
    	font-weight: normal;
    }
    .auto-style8 {
    	background-color: #484800;
    }
  </style>
</head>

<body onload="prettyPrint();">
  <h1 class="auto-style7">std::async (c++11)</h1>
  
  <p> <strong>std::async</strong> は、C++11 
  で導入された非同期処理のための関数テンプレートです。</p>
  <p> バックグラウンドで関数を非同期に実行し、その結果を <strong>std::future</strong> 
  経由で取得することができます。</p>
  <p> &nbsp;</p>
  
  <div class="mokuji">
    <nav>
  	<h2>目次</h2>
  	<p><a href="#1._C++標準の非同期処理_(std::thread,_std::jthread,_std::async)">1. C++標準の非同期処理 (std::thread, std::jthread, std::async)</a></p>
    <p><a href="#2._std::async_のシンプルな使用例">2. std::async のシンプルな使用例</a></p>
  	<p><a href="#3._一時停止状態のスレッドを作る">3. 一時停止状態のスレッドを作る</a></p>
  	<p><a href="#4._async_で作成したスレッドの終了を待たずに_main_を終了したらどうなる？">4. async で作成したスレッドの終了を待たずに main を終了したらどうなる？</a></p>
  	<p>&nbsp;</p>
  	<p><a href="#ライセンス">ライセンス</a></p>
  	<p><a href="#参考">参考</a></p>
    </nav>
  </div>
  
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  
  <section>
  <h2><a name="1._C++標準の非同期処理_(std::thread,_std::jthread,_std::async)">1. C++標準の非同期処理 (std::thread, std::jthread, std::async)</a> </h2>
  <p>C++標準には、非同期処理を行う方法に <strong>std::thread</strong>, <strong>std::jthread</strong>, 
  <strong>std::async</strong> の3つがあります。</p>
  <p>最初にこの3つについて概要を記載します。</p>
  <p>&nbsp;</p>
  <p style="white-space: normal;">🦊 <strong>参考（選び方の目安）</strong></p>
  <div style="white-space: normal;">
    <table class="border-collapse" border="1" width="600">
      <thead class="standard_table">
        <tr style="white-space: normal;">
          <th style="white-space: normal; height: 30px;">
          <span style="white-space: normal;">目的</span></th>
          <th style="white-space: normal; height: 30px;">
          <span style="white-space: normal;">推奨される選択肢</span></th>
        </tr>
      </thead>
      
      <tbody style="white-space: normal;">
        <tr style="white-space: normal;">
          <td style="white-space: normal;"><span style="white-space: normal;">スレッドを完全に制御したい</span></td>
          <td style="white-space: normal;"><code style="white-space: normal;">
          <span style="white-space: normal;">std::thread</span></code></td>
        </tr>
        <tr style="white-space: normal;">
          <td style="white-space: normal;"><span style="white-space: normal;">安全にスレッドを扱いたい（C++20 以降）</span></td>
          <td style="white-space: normal;"><code style="white-space: normal;">
          <span style="white-space: normal;">std::jthread</span></code></td>
        </tr>
        <tr style="white-space: normal;">
          <td style="white-space: normal;"><span style="white-space: normal;">戻り値が必要な非同期処理を簡単に書きたい</span></td>
          <td style="white-space: normal;"><code style="white-space: normal;">
          <span style="white-space: normal;">std::async</span></code></td>
        </tr>
    </table>
  </div>
  
  <p>&nbsp;</p>
  <h3>🧵 <code style="white-space: normal;">std::thread</code></h3>
    <table class="border-collapse" border="1" width="600">
      <tbody>
        <tr>
          <td><strong style="white-space: pre-wrap;">特徴</strong></td>
          <td>最も基本的なスレッド。スレッドの生成と管理を自分で行う。</td>
        </tr>
        <tr>
          <td><strong style="white-space: pre-wrap;">利点</strong></td>
          <td>細かい制御が可能（スレッドのライフサイクル、優先度など）</td>
        </tr>
        <tr>
          <td><strong style="white-space: pre-wrap;">注意点</strong></td>
          <td>
      <ul>
        <li>
          <p>
          <code style="white-space: pre-wrap;" class="cpp-source">join()</code> や 
          <code style="white-space: pre-wrap;" class="cpp-source">detach()</code> 
          を忘れると未定義動作になる</p></li>
        <li><p>スレッド終了の管理が手動で面倒。</p></li>
      </ul>
          </td>
        </tr>
        <tr>
          <td style="white-space: nowrap"><strong>使いどころ</strong></td>
          <td>スレッドの寿命や動作を細かく制御したいとき</td>
        </tr>
      </tbody>
    </table>
    
  <p>&nbsp;</p>
  
  <h3 style="white-space: normal;">🌿 <code style="white-space: normal;">
  std::jthread （C++20〜）</code></h3>
    <table class="border-collapse" border="1" width="600">
      <tbody>
        <tr>
          <td><strong style="white-space: pre-wrap;">特徴</strong></td>
          <td><code style="white-space: pre-wrap;"><strong>std::thread</strong></code> 
    の改良版。スレッド終了時に自動で <code style="white-space: pre-wrap;">join()</code> してくれる</td>
        </tr>
        <tr>
          <td><strong style="white-space: pre-wrap;">利点</strong></td>
          <td>
    <ul>
      <li><p>リソースリークの心配が少ない（RAIIで自動管理）</p></li>
      <li>
      <p style="white-space: normal;">
      <code style="white-space: pre-wrap;" class="cpp-source">stop_token</code> 
      によるキャンセル機構が組み込まれている</p>
      </li>
    </ul>
          </td>
        </tr>
        <tr>
          <td><strong style="white-space: pre-wrap;">注意点</strong></td>
          <td>
    <ul style="white-space: normal;">
      <li style="white-space: normal;">
      <p style="white-space: normal;">C++20以降が必要</p>
      </li>
      <li style="white-space: normal;">
      <p style="white-space: normal;">一部の環境ではまだ完全にサポートされていないかも</p>
      </li>
    </ul>
          </td>
        </tr>
        <tr>
          <td style="white-space: nowrap"><strong>使いどころ</strong></td>
          <td>スレッドのキャンセルや自動管理が欲しいとき。C++20が使えるならこちらが安全。</td>
        </tr>
      </tbody>
    </table>
    
    <p>&nbsp;</p>
    <h3>⚡ <code>std::async</code></h3>
    <table class="border-collapse" border="1" width="600">
      <tbody>
        <tr>
          <td><strong style="white-space: pre-wrap;">特徴</strong></td>
          <td>関数を非同期に実行し、<code style="white-space: pre-wrap;" class="cpp-source">std::future</code> 
    で結果を取得。</td>
        </tr>
        <tr>
          <td><strong style="white-space: pre-wrap;">利点</strong></td>
          <td>
    <ul style="white-space: normal;">
      <li style="white-space: normal;">
      <p style="white-space: normal;">戻り値を簡単に取得できる</p>
      </li>
      <li style="white-space: normal;">
      <p style="white-space: normal;">スレッド管理が不要</p>
      </li>
      <li style="white-space: normal;">
      <p style="white-space: normal;">リソースリークの心配が少ない（RAIIで自動管理）</p>
      </li>
    </ul>
          </td>
        </tr>
        <tr>
          <td><strong style="white-space: pre-wrap;">注意点</strong></td>
          <td>
    <ul style="white-space: normal;">
      <li style="white-space: normal;">
      <p style="white-space: normal;">実行ポリシー（<code style="white-space: pre-wrap;">std::launch::async</code> or
      <code style="white-space: pre-wrap;">deferred</code>）に注意。</p>
      </li>
      <li style="white-space: normal;">
      <p style="white-space: normal;">実装依存でスレッドが作られないこともある。</p>
      </li>
      <li style="white-space: normal;">
      <p style="white-space: normal;"><span class="cpp-source">
      std::launch::async</span> を使って新しいスレッドを起動した場合、<span class="cpp-source">future.get()</span> 
      や <span class="cpp-source">wait()</span> を呼ばずに future 
      を破棄すると、スレッドがバックグラウンドで動いたままになる可能性がある。</p>
      </li>
      <li style="white-space: normal;">
      <p style="white-space: normal;"><span class="cpp-source">
      std::launch::deferred</span> の場合、<span class="cpp-source">get()</span> 
      を呼ばないと関数自体が実行されない。 </p>
      </li>
    </ul>
          </td>
        </tr>
        <tr>
          <td style="white-space: nowrap"><strong>使いどころ</strong></td>
          <td>「関数を非同期に呼び出して結果を待ちたい」ようなシンプルなケースに最適</td>
        </tr>
      </tbody>
    </table>
    
    <p>&nbsp;</p>
    <p>以下、本ページでは <strong>std::async</strong> について記載します。</p>
    <p>&nbsp;</p>

  </section>

  <p>&nbsp;</p>

  <section>
    <h2> <a name="2._std::async_のシンプルな使用例">2. std::async のシンプルな使用例</a></h2>
    <p> [概要]</p>
    <p> <strong>std::async</strong> を使って、まずはシンプルなサンプルを作ってみます。<br>少し処理の重たい関数 <span class="cpp-source">calcurateSum()</span> を準備して、これを  
    <strong>std::async</strong> で実行します。</p>
    <p> &nbsp;</p>
    
    <p>[評価環境]</p>
    <table>
    <tbody>
    	<tr>
    		<td class="td_separate" colspan="3"></td>
    	</tr>
    	
    	<tr>
    		<td>コンパイラ :</td>
    		<td>g++ (Ubuntu 13.3.0-6ubuntu2~24.04),</td>
    		<td>13.3.0</td>
    	</tr>
    	
    	<tr>
    		<td class="td_separate" colspan="3"></td>
    	</tr>
    	
    	<tr>
    		<td>OS: </td>
    		<td>Ubuntu 24.04 (WSL),</td>
    		<td></td>
    	</tr>
    	
    	<tr>
    		<td class="td_separate" colspan="3"></td>
    	</tr>
    </tbody>
    </table>
    
    <p> &nbsp;</p>
    <p>[プログラムソース] "<span class="cpp-source">async_01.cpp</span>"</p>
  
    <pre class="prettyprint linenums lang-cpp" style="width:1200px">
#include &lt;iostream&gt;     // std::cout, std::endl
#include &lt;vector&gt;       // std::vector
#include &lt;future&gt;       // std::async, std::future
#include &lt;chrono&gt;       // chrono::seconds, chrono::milliseconds, chrono::microseconds
#include &lt;thread&gt;       // std::this_thread::sleep_for
#include &lt;string&gt;       // std::string
#include &lt;functional&gt;   // std::cref

/// @brief data の合計値を計算する
/// @param data : 合計値を計算するデータ
/// @return data の合計値
int calcurateSum(const std::vector&lt;int&gt;&amp; data)
{
    int sum = 0;
    for (auto i : data) {
        // 重たい処理
        std::this_thread::sleep_for(std::chrono::milliseconds(2000));
        sum += i;
        std::cout &lt;&lt; "sum = " &lt;&lt; sum &lt;&lt; std::endl;
    }

    //throw std::runtime_error("test");

    return sum;
}

/// @brief std::async (非同期処理) のサンプルコード
/// @return EXIT_SUCCESS
int main()
{
    std::vector&lt;int&gt; data = { 1, 2, 3, 4, 5 };

    // calcurateSum() 関数を実行する
    // 引数が const なので cref() を使用。変更可能な場合は ref() で参照渡し。 
//  future&lt;int&gt; f = std::async( launch::async, calcurateSum, cref(data) );                     // 非同期実行
//  future&lt;int&gt; f = std::async( launch::deferred, calcurateSum, cref(data) );                  // 同期実行
//  future&lt;int&gt; f = std::async( launch::async | launch::deferred, calcurateSum, cref(data) );  // 非同期/同期 どちらでもOK
//  future&lt;int&gt; f = std::async( calcurateSum, cref(data));                                     // 非同期/同期 どちらでもOK
    auto f = std::async( std::launch::async, calcurateSum, cref(data));                        // auto による推奨の使用方法。非同期実行。
    try {
        if (f.wait_for(std::chrono::seconds(0)) == std::future_status::deferred) {
            // launch::deferred is selected.
            std::cout &lt;&lt; "data の合計値は " &lt;&lt; f.get() &lt;&lt; "です" &lt;&lt; std::endl;
        }
        else {
            // launch::async is selected.
            while (1) {
                if ( f.wait_for(std::chrono::milliseconds(500)) == std::future_status::ready ) {
                    std::cout &lt;&lt; "data の合計値は " &lt;&lt; f.get() &lt;&lt; "です" &lt;&lt; std::endl;
                    break;
                }
                else {
                    std::cout &lt;&lt; "wait..." &lt;&lt; std::endl;
                }
            }
        }
    }
    catch (const std::exception&amp; ex) {
        std::cout &lt;&lt; "exception catched: " &lt;&lt; ex.what() &lt;&lt; std::endl;
    }
    catch (...) {
        std::cout &lt;&lt; "exception catched." &lt;&lt; std::endl;
    }

    return EXIT_SUCCESS;
}</pre>

    <p>&nbsp;</p>
    <p>ビルド方法：</p>
    
    <pre class="prettyprint" style="width:800px">$ g++ -std=c++20 -Wall -Wextra -Wpedantic -pthread -O2 async_01.cpp -o async_01.out</pre>
    
    <p>&nbsp;</p>
    <p>Makefile 例：</p>
    
    <pre class="prettyprint linenums lang-cpp" style="width:800px">
CXX := g++
CXXFLAGS := -std=c++23 -O2 -Wall -Wextra -Wpedantic -pthread

ifeq ($(DEBUG),1)
    CXXFLAGS += -g
endif

SRC := async_01.cpp
OUT := $(SRC:.cpp=.out)

.PHONY: all run clean help

all: $(OUT)

$(OUT): $(SRC)
	@printf "Compiling %s -&gt; %s\n" "$&lt;" "$@"
	$(CXX) $(CXXFLAGS) "$&lt;" -o "$@"

run: $(OUT)
	@./$(OUT)

clean:
	@rm -f $(OUT)

help:
	@printf "Usage:\n"
	@printf "  make         Build async_01.cpp -&gt; async_01.out\n"
	@printf "  make run     Build then run the binary\n"
	@printf "  make clean   Remove generated binary\n"
	@printf "  make help    Show this help message\n"</pre>
    
    <p>&nbsp;</p>
    
    <table class="border-collapse" border="1" style="width: 800px">
      <caption>ビルドオプション説明：</caption>
      <thead class="standard_table">
        <tr>
          <th>オプション</th>
          <th>説明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="white-space: nowrap;"><strong>-std=c++23</strong></td>
          <td>C++23 標準でコンパイルします。言語機能（構文・ライブラリ仕様）が C++23 準拠になります。 </td>
        </tr>
        <tr>
          <td><strong>-Wall&nbsp;</strong></td>
          <td>一般的な警告群を有効にします。コード品質の初期チェックに有用です。 </td>
        </tr>
        <tr>
          <td><strong>-Wextra</strong></td>
          <td><strong>-Wall</strong>&nbsp;に含まれない追加の警告を有効にします。未使用パラメータなどを検出します。 </td>
        </tr>
        <tr>
          <td style="white-space: nowrap;"><strong>-Wpedantic</strong></td>
          <td>規格に厳格に従っていない拡張や非標準的記法を警告します。移植性を高めたい場合に有効です。 </td>
        </tr>
        <tr>
          <td><strong>-pthread</strong></td>
          <td>POSIX threads 
          のサポートを有効にし、スレッド関連のライブラリをリンクします。単に&nbsp;-lpthread&nbsp;をリンクするだけでなく、コンパイル時にスレッド対応（スレッドセーフな定義など）を有効にするフラグです。スレッド/ミューテックスなどを使うプログラムでは必須に近いオプションです（Linux）。 </td>
        </tr>
        <tr>
          <td><strong>-O2</strong></td>
          <td>最適化レベル 2 を指定します。実行速度向上のための最適化を行うが、"<strong>-O3</strong>" よりは穏やかで安定的な設定です。デバッグ時は 
          "<strong>-g -O0</strong>" 
          を推奨します。 </td>
        </tr>
      </tbody>
    </table>
    
    <p>&nbsp;</p>
    <p>実行結果：</p>
    <pre class="prettyprint" style="width:600px">
$ ./async_01.out 
wait...
wait...
wait...
sum = 1
wait...
wait...
wait...
wait...
sum = 3
wait...
wait...
wait...
wait...
sum = 6
wait...
wait...
wait...
wait...
sum = 10
wait...
wait...
wait...
wait...
sum = 15
data の合計値は 15です
$ </pre>
    <p>&nbsp;</p>

    <p>補足説明：</p>
    <ul>
    	<li><strong>std::async</strong> の第一引数に <span class="cpp-source">launch::async</span> を指定した場合、内部的にスレッドを生成して非同期の動作を行います。<br>
        <strong>std::async</strong> の第一引数に <span class="cpp-source">launch::deferred</span> を指定した場合は同期実行します。通常の関数動作とお考え下さい。<br>
        <strong>std::async</strong> の第一引数を 無指定、または &quot;<span class="cpp-source">launch::async | 
    	launch::deferred</span>&quot; を指定した場合、どちらで実行しても良い、という意図になります。<br>
        <strong>std::async</strong> 
    	を使用する時点で非同期実行を意図しているはずなので、通常は <span class="cpp-source">launch::async</span> を明示的に指定することになるはずです。<br></li>
    	<li>非同期実行の場合、対象のタスクが終了しているかを確認してから結果を取得します。<br>上記例では "<span class="cpp-source">f.wait_for(chrono::milliseconds(500)) == std::future_status::ready</span>" 
        の処理で最大 500ms の時間だけ処理完了を待ちます。その後 <span class="cpp-source">f.get()</span> を実行することで処理結果を取得します。</li>
    	<li>同期実行であることが明確な場合は、状態を確認する必要ありません。同期実行の場合、<span class="cpp-source">f.get()</span> を実行するまで処理自体が行われません。</li>
    	<li>非同期/同期 のどちらで実行しているかがわからない場合、両方を考慮したプログラム実装を行う必要があります。<br>プログラム品質を下げる原因となるので、特に理由なければ 同期/非同期 をちゃんと決めてプログラムの実装とテストを行う方が良いでしょう。</li>
    </ul>

    <p>&nbsp;</p>
    <p>参考URL：</p>
    <ul>
    	<li><a href="http://ja.cppreference.com/w/cpp/thread/async" target="_blank">
    	http://ja.cppreference.com/w/cpp/thread/async</a></li>
    </ul>
    
    <p>&nbsp;</p>
  </section>
  
  <p>&nbsp;</p>

<section>
  <h2><a name="3._一時停止状態のスレッドを作る">3. 一時停止状態のスレッドを作る</a></h2>
  <p>一時停止状態のシステムスレッドを作成してみます。<br>
  すなわち、スレッドで何かを処理する時が来たらすぐに開始できるように、あらかじめスレッドを作成しておき、スレッドの作成によるオーバーヘッドによる遅延を回避する例です。または、実行開始前にスレッドに何かしらの設定を行う必要があるため、一時停止状態のスレッドを作成する場合もあるでしょう。<br>
  スレッドを一度だけ一時停止状態にしたい場合は、void な future を用いるのが妥当な選択です。この技法の要点を以下に示します。</p>
  <p>&nbsp;</p>
  <p>[評価環境]</p>
  <table>
  <tbody>
    <tr>
      <td class="td_separate" colspan="3"></td>
    </tr>
    
    <tr>
      <td>コンパイラ :</td>
      <td>Visual Studio 2019 pro.,</td>
      <td>Version 16.3.10 </td>
    </tr>
    
    <tr>
      <td class="td_separate" colspan="3"></td>
    </tr>
    
    <tr>
      <td>OS: </td>
      <td>Windows10 home,</td>
      <td>Version 1909 </td>
    </tr>
    
    <tr>
      <td class="td_separate" colspan="3"></td>
    </tr>
  </tbody>
  </table>

  <p>&nbsp;</p>

  <p>[プログラムソース] "<span class="cpp-source">async_02.cpp</span>"</p>
  <pre class="prettyprint linenums lang-cpp">
#include &lt;iostream&gt;
#include &lt;future&gt;		// std::async

using namespace std;

int react( int count )
{
    cout &lt;&lt; &quot;Start react().&quot; &lt;&lt; endl;
    for (int i = 0; i &lt; count; ++i) {
        this_thread::sleep_for(chrono::milliseconds(1000));
    }
    cout &lt;&lt; &quot;Finish react().&quot; &lt;&lt; endl;
    return 1;
}

int main()
{
    <span class="auto-style8">promise&lt;void&gt; p;</span>
    int wait_count = 5;

    future&lt;int&gt; f = async(launch::async, [=,&amp;p]
    {
      <span class="auto-style8">p.get_future().wait();</span>                                // p.set_value() の実行まで待機
      return react(wait_count);                             // react() を実行
    });

    this_thread::sleep_for(chrono::seconds(1));             // 何か…をしてから、
    <span class="auto-style8">p.set_value();</span>                                          // スレッドを起動します。

    cout &lt;&lt; &quot;f.get() = &quot; &lt;&lt; f.get() &lt;&lt; endl;                // react() の完了を待って戻り値を取得
    cout &lt;&lt; &quot;Confirmed termination of react().&quot; &lt;&lt; endl;
}</pre>

  <p>&nbsp;</p>
  <p>[実行結果]</p>
  <p><img alt="実行結果" src="async/img5.gif"></p>
  <p>&nbsp;</p>
  <h4>参考</h4>
  <ul>
    <li>「Effective Modern C++」 項目39：イベントが１度切ならば void な future を検討する</li>
    <li><a href="http://ja.cppreference.com/w/cpp/thread/async" target="_blank">
    http://ja.cppreference.com/w/cpp/thread/async</a></li>
  </ul>

  <p>&nbsp;</p>
  <p>&nbsp;</p>
</section>

<p>&nbsp;</p>

<section>
  <h2><a name="4._async_で作成したスレッドの終了を待たずに_main_を終了したらどうなる？">4. async で作成したスレッドの終了を待たずに main を終了したらどうなる？</a></h2>
  <p>[概要]</p>
  <p> std::thread だと join または detatch が必須です。<br>std::async の場合は detatch 
  に相当する機能がないけれど、終了確認せずに worker スレッドを放置したらどうなるのでしょうか。<br>確認してみました。</p>
  <p> &nbsp;</p>

  <p>[環境]</p>
  <table>
  <tbody>
    <tr>
      <td class="td_separate" colspan="3"></td>
    </tr>
    
    <tr>
      <td>コンパイラ :</td>
      <td>Visual Studio 2019 pro.,</td>
      <td>Version 16.6.0 </td>
    </tr>
    
    <tr>
      <td class="td_separate" colspan="3"></td>
    </tr>
    
    <tr>
      <td>OS: </td>
      <td>Windows10 home,</td>
      <td>Version 1909 </td>
    </tr>
    
    <tr>
      <td class="td_separate" colspan="3"></td>
    </tr>
  </tbody>
  </table>

  <p> &nbsp;</p>

  <p>[プログラムソース] "<span class="cpp-source">async_03.cpp</span>"</p>
  <pre class="prettyprint linenums lang-cpp"><code>
#include &lt;iostream&gt;
#include &lt;vector&gt;   // vector
#include &lt;chrono&gt;   // chrono
#include &lt;thread&gt;   // this_thread
#include &lt;future&gt;   // async, future, future_status

#include &lt;windows.h&gt;    // OuputDebugString
#include &lt;tchar.h&gt;      // _T

using namespace std;


int worker(const vector&lt;int&gt;&amp; data)
{
    int sum = 0;

    for (int i : data) {
        // 重たい処理
        this_thread::sleep_for(chrono::milliseconds(2000));
        sum += i;
        cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;
    }

    //throw std::wstring(L&quot;test&quot;);

    return sum;
}


int main()
{
    vector&lt;int&gt; data = { 1, 2, 3, 4, 5 };

    // worker() 関数を実行する
    future&lt;int&gt; f = std::async( launch::async, worker, ref(data) );                     // 非同期実行

    // このまま worker スレッドの終了を待たずに終了... どうなる？
    // std::thread なら join または detatch が必要だけど...
    cout &lt;&lt; &quot;[INF] Finish main task.&quot; &lt;&lt; endl;

    return EXIT_SUCCESS;
}</code>
  </pre>
    
  <p>&nbsp;</p>
  <p>[実行結果]</p>
  <p><img alt="実行結果" src="async/imgA.jpg"></p>
  <p>&nbsp;</p>
  <p><strong>結論：</strong></p>
  <p> どうやら特に考慮は不要のようです。<br>main タスクが終了しても <strong>std::async</strong> タスクの動作は継続しました。<br>逆に  
  <span class="cpp-source">main()</span> が終了したにもかかわらず async タスク側が残ってしまう場合もあるので、必要に応じて main タスク終了時に別スレッドを適切に終了するという処理が必要そうです。</p>
  <p>&nbsp;</p>
</section>

<p>&nbsp;</p>

<section>
  <h2><a name="ライセンス">ライセンス</a></h2>
  <p>本ページの情報は、特記無い限り下記 MIT ライセンスで提供されます。</p>
  <table class="border-collapse" style="width: 600px; background-color: #F0F0F0; word-break: break-word;">
    <tr>
      <td>
  MIT License<br><br>

      Copyright (c) 2017  Kinoshita Hidetoshi<br><br>

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:<br><br>

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.<br><br>

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
      </td>
    </tr>
  </table>
  <p>&nbsp;</p>
</section>

<p>&nbsp;</p>

<section>
	<h2><a name="参考">参考</a></h2>
	<ul>
	<li><a href="http://ja.cppreference.com/w/cpp/thread/async" target="_blank">
	http://ja.cppreference.com/w/cpp/thread/async</a></li>
	</ul>
</section>

<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>

<section>
	<h2 style="margin-bottom:5px">記載</h2>
	<table>
	  <tr>
	    <td class="td_history_date">2026-02-11</td>
	    <td class="td_history_separator">-</td>
	    <td class="td_history">
        「<a href="#1._C++標準の非同期処理_(std::thread,_std::jthread,_std::async)">1. C++標準の非同期処理 (std::thread, std::jthread, std::async)</a>」を追加<br>
        「<a href="#2._std::async_のシンプルな使用例">2. std::async のシンプルな使用例</a>」を更新
        </td>
	  </tr>
	  <tr>
	    <td class="td_history_date">2022-06-10</td>
	    <td class="td_history_separator">-</td>
	    <td class="td_history">ページデザインを更新</td>
	  </tr>
	  <tr>
	    <td class="td_history_date">2020-05-31</td>
	    <td class="td_history_separator">-</td>
	    <td class="td_history">「<a href="#3._async_で作成したスレッドの終了を待たずに_main_を終了したらどうなる？">3. async で作成したスレッドの終了を待たずに main を終了したらどうなる？</a>」を追加<br></td>
	  </tr>
	  <tr>
	    <td class="td_history_date">2019-11-27</td>
	    <td class="td_history_separator">-</td>
	    <td class="td_history">「<a href="#2._一時停止状態のスレッドを作る">2. 一時停止状態のスレッドを作る</a>」の章を追加</td>
	  </tr>
	  <tr>
	    <td class="td_history_date">2017-11-18</td>
	    <td class="td_history_separator">-</td>
	    <td class="td_history">新規作成 </td>
	  </tr>
	</table>
</section>

<p> &nbsp;</p>

<section>
<p><a href="../../index.html" target="_parent">Programming Items トップページ</a></p>
<p><a href="../../privacy_policy.html">プライバシーポリシー</a></p>
</section>

<p>&nbsp;</p>

<footer>
  <p><small>© copyright 2017 木下英俊</small></p>
</footer>

</body>
</html>
