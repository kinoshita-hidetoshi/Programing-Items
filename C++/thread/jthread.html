<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="kinoshita hidetoshi (木下 英俊)">
  <meta name="description" content="木下英俊が自身のためにプログラムメモを残すことを目的に作成したページです">
  <meta name="keywords" content="">
  <!-- キャッシュ無効化 -->
  <meta http-equiv="Cache-Control" content="no-cache">
	
  <!-- タイトル -->
  <title>std::jthread | Programming Items</title>
	
  <!-- ファビコン -->
  <link rel="shortcut icon" href="../../favicon.ico">
  
  <!-- CSS -->
  <link href="https://unpkg.com/ress/dist/ress.min.css" rel="stylesheet">
	<link rel="stylesheet" href="../../design.css" type="text/css">
  
	<!-- Start for 'google-code-prettify' -->
	<link href="../../prettify/styles/desert.css" rel="stylesheet" type="text/css">
	<script src="../../prettify/prettify.js" type="text/javascript"></script>
	<!-- End for 'google-code-prettify' -->	
	
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-V2DZQK54C2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'G-V2DZQK54C2');
  </script>
  <!-- Global site tag (gtag.js) - Google Analytics -->

</head>

<body onload="prettyPrint();">
	
  <h1>std::jthread (c++20)</h1>
  
  <p> &nbsp;</p>
  <p> <strong>std::jthread</strong> は、C++20 で導入された 「自動キャンセル機能付きの安全なスレッド」 です。従来の 
  <strong>std::thread</strong> の欠点を補い、より扱いやすく、例外安全なスレッド管理を可能にします。 </p>
  
  <p>&nbsp;</p>
  
  <div class="mokuji">
    <nav>
    	<h2>目次</h2>
      <p><a href="#1._C++標準の非同期処理_(std::thread,_std::jthread,_std::async)">1. C++標準の非同期処理 (std::thread, std::jthread, std::async)</a></p>
    	<p><a href="#2._std::jthread_の特徴">2. std::jthread の特徴</a></p>
    	<p><a href="#3._std::jthread_を使ってみる">3. std::jthread を使ってみる</a></p>
      <p><a href="#4._request_stop()_しないとどうなる？">4. request_stop() しないとどうなる？</a></p>
    	<p>&nbsp;</p>
    	<p><a href="#ライセンス">ライセンス</a></p>
    	<p><a href="#参考">参考</a></p>
    </nav>
  </div>
  
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  
  <section>
    <h2><a name="1._C++標準の非同期処理_(std::thread,_std::jthread,_std::async)">1. C++標準の非同期処理 (std::thread, std::jthread, std::async)</a> </h2>
    <p>C++標準には、非同期処理を行う方法に <strong>std::thread</strong>, <strong>std::jthread</strong>, 
    <strong>std::async</strong> の3つがあります。</p>
    <p>最初にこの3つについて概要を記載します。</p>
    <p>&nbsp;</p>
    
    <h3 style="white-space: normal;">🦊 <strong>参考（選び方の目安）</strong></h3>
    <div style="white-space: normal;">
      <table class="border-collapse" border="1" width="600">
        <thead class="standard_table">
          <tr style="white-space: normal;">
            <th style="white-space: normal; height: 30px;">
            <span style="white-space: normal;">目的</span></th>
            <th style="white-space: normal; height: 30px;">
            <span style="white-space: normal;">推奨される選択肢</span></th>
          </tr>
        </thead>
        
        <tbody style="white-space: normal;">
          <tr style="white-space: normal;">
            <td style="white-space: normal;"><span style="white-space: normal;">スレッドを完全に制御したい</span></td>
            <td style="white-space: normal;"><code style="white-space: normal;">
            <span style="white-space: normal;">std::thread</span></code></td>
          </tr>
          <tr style="white-space: normal;">
            <td style="white-space: normal;"><span style="white-space: normal;">安全にスレッドを扱いたい</span></td>
            <td style="white-space: normal;"><code style="white-space: normal;">
            <span style="white-space: normal;">std::jthread</span></code></td>
          </tr>
          <tr style="white-space: normal;">
            <td style="white-space: normal;"><span style="white-space: normal;">戻り値が必要な非同期処理を簡単に書きたい</span></td>
            <td style="white-space: normal;"><code style="white-space: normal;">
            <span style="white-space: normal;">std::async</span></code></td>
          </tr>
      </table>
    </div>
    
    <p>&nbsp;</p>
    
    <h3>🧵 std::thread</h3>
    <table class="border-collapse" border="1" width="600">
      <tbody>
        <tr>
          <td><strong style="white-space: pre-wrap;">特徴</strong></td>
          <td>最も基本的なスレッド。スレッドの生成と管理を自分で行う。</td>
        </tr>
        <tr>
          <td><strong style="white-space: pre-wrap;">利点</strong></td>
          <td>細かい制御が可能（スレッドのライフサイクル、優先度など）</td>
        </tr>
        <tr>
          <td><strong style="white-space: pre-wrap;">注意点</strong></td>
          <td>
            <ul>
              <li>
                <code style="white-space: pre-wrap;" class="cpp-source">join()</code> や 
                <code style="white-space: pre-wrap;" class="cpp-source">detach()</code> 
                を忘れると未定義動作になる</li>
              <li>スレッド終了の管理が手動で面倒</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td style="white-space: nowrap"><strong>使いどころ</strong></td>
          <td>スレッドの寿命や動作を細かく制御したいとき</td>
        </tr>
      </tbody>
    </table>
    
    <p>&nbsp;</p>
    
    <h3>🌿 std::jthread</h3>
    <table class="border-collapse" border="1" width="600">
      <tbody>
        <tr>
          <td><strong style="white-space: pre-wrap;">特徴</strong></td>
          <td><code style="white-space: pre-wrap;"><strong>std::thread</strong></code> 
            の改良版。スレッド終了時に自動で <code style="white-space: pre-wrap;">join()</code> してくれる</td>
        </tr>
        <tr>
          <td><strong style="white-space: pre-wrap;">利点</strong></td>
          <td>
            <ul>
              <li>リソースリークの心配が少ない（RAIIで自動管理）</li>
              <li><code style="white-space: pre-wrap;" class="cpp-source">stop_token</code> によるキャンセル機構が組み込まれている</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td><strong style="white-space: pre-wrap;">注意点</strong></td>
          <td>
            <ul style="white-space: normal;">
              <li style="white-space: normal;">C++20以降が必要</li>
              <li style="white-space: normal;">一部の環境ではまだ完全にサポートされていないかも</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td style="white-space: nowrap"><strong>使いどころ</strong></td>
          <td>スレッドのキャンセルや自動管理が欲しいとき。<br>C++20 を使えるなら <strong>std::thread</strong> 
          よりこちらの方が安全。</td>
        </tr>
      </tbody>
    </table>
    
    <p>&nbsp;</p>
    <h3>⚡ std::async</h3>
    <table class="border-collapse" border="1" width="600">
      <tbody>
        <tr>
          <td><strong style="white-space: pre-wrap;">特徴</strong></td>
          <td>関数を非同期に実行し、<code style="white-space: pre-wrap;" class="cpp-source">std::future</code> 
            で結果を取得。</td>
        </tr>
        <tr>
          <td><strong style="white-space: pre-wrap;">利点</strong></td>
          <td>
            <ul style="white-space: normal;">
              <li style="white-space: normal;">戻り値を簡単に取得できる</li>
              <li style="white-space: normal;">スレッド管理が不要</li>
              <li style="white-space: normal;">リソースリークの心配が少ない（RAIIで自動管理）</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td><strong style="white-space: pre-wrap;">注意点</strong></td>
          <td>
            <ul style="white-space: normal;">
              <li style="white-space: normal;">
              実行ポリシー 
              (<span class="cpp-source">std::launch::async</span> or
              <span class="cpp-source">std::launch::deferred</span>) に注意。実装依存でスレッドが作られないこともある。</li>
              <li style="white-space: normal;">
              <span class="cpp-source">
              std::launch::async</span> を使って新しいスレッドを起動した場合、future 
              の <span class="cpp-source">get()</span> 
              や <span class="cpp-source">wait()</span> を呼ばずに future 
              を破棄すると、スレッドがバックグラウンドで動いたままになる可能性がある。</li>
              <li style="white-space: normal;">
              <span class="cpp-source">
              std::launch::deferred</span> の場合、スレッドを作成しない。また、future 
              の <span class="cpp-source">get()</span> 
              を呼ばないと関数自体が実行されない。</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td style="white-space: nowrap"><strong>使いどころ</strong></td>
          <td>「関数を非同期に呼び出して結果を待ちたい」ようなシンプルなケースに最適</td>
        </tr>
      </tbody>
    </table>
    
    <p>&nbsp;</p>
    <p>以下、本ページでは <strong>std::jthread</strong> について記載します。</p>
    <p>&nbsp;</p>

  </section>

  <p>&nbsp;</p>
  
  <section>
  	<h2> <a name="2._std::jthread_の特徴">2. std::jthread の特徴</a></h2>
    <p> std::jthread は以下のような特徴があります。</p>
    <p> &nbsp;</p>
    <ol>
      <li><strong>stop_token</strong> による協調的キャンセル<br><strong>std::jthread</strong> の最大の利点がこれです。 <br>
      スレッド開始時に <strong>std::stop_token</strong> が渡され、外側から <strong>stop_request</strong> 
      を送ることでスレッドに終了を依頼できます。 <br>強制終了ではなく「協調的キャンセル」なので安全です。<br><br>
      <li>コンストラクタで <strong>stop_token</strong> を自動注入<br><strong>std::jthread</strong> 
      のコンストラクタは、スレッド関数の第一引数が <strong>std::stop_token</strong> なら自動的に渡します。<br><br></li>
      <li>スレッド終了時に自動 <strong>join</strong><br><strong>std::thread</strong> はデストラクタで  
      <strong>join</strong> しないため、 <strong>join</strong> を忘れると 
      <strong>std::terminate</strong> が発生する危険がありました。<br><strong>std::jthread</strong> は、デストラクタで自動的に  
      <strong>join</strong> します。<br><strong>std::jthread</strong> は、デストラクタで自動的に  
      <strong>stop_request</strong> を送信します。<br>
      <ul>
        <li>join の書き忘れがない</li>
        <li>例外が発生しても安全にスレッドが終了する</li>
      </ul>
      </li>
      <li><strong>std::thread</strong> と同じように使える<br>基本的な <strong>API</strong>（<strong>joinable</strong>、<strong>get_id</strong> 
      など）は std::<strong>thread</strong> と同じです。ただし <strong>detach</strong> 
      はありません（自動 <strong>join</strong> 
      が前提のため）。 </li>
    </ol>
    <p>&nbsp;</p>
    <p>
    
    <table class="border-collapse" border="1" width="600">
      <caption>🆚 std::thread との比較</caption>
      <thead class="standard_table">
        <tr style="white-space: normal;">
          <th style="white-space: normal;"><span style="white-space: normal;">機能</span></th>
          <th style="white-space: normal;"><span style="white-space: normal;">
          std::thread</span></th>
          <th style="white-space: normal;"><span style="white-space: normal;">
          std::jthread</span></th>
        </tr>
      </thead>
      <tbody style="white-space: normal;">
        <tr style="white-space: normal;">
          <td style="white-space: normal;"><span style="white-space: normal;">デストラクタで join</span></td>
          <td style="white-space: normal;"><span style="white-space: normal;">❌ 
          しない</span></td>
          <td style="white-space: normal;"><span style="white-space: normal;">✅ 
          自動で join</span></td>
        </tr>
        <tr style="white-space: normal;">
          <td style="white-space: normal;"><span style="white-space: normal;">キャンセル機構</span></td>
          <td style="white-space: normal;"><span style="white-space: normal;">❌ 
          なし</span></td>
          <td style="white-space: normal;"><span style="white-space: normal;">✅ 
          stop_token で協調的キャンセル</span></td>
        </tr>
        <tr style="white-space: normal;">
          <td style="white-space: normal;"><span style="white-space: normal;">detach</span></td>
          <td style="white-space: normal;"><span style="white-space: normal;">あり</span></td>
          <td style="white-space: normal;"><span style="white-space: normal;">なし</span></td>
        </tr>
        <tr style="white-space: normal;">
          <td style="white-space: normal;"><span style="white-space: normal;">例外安全性</span></td>
          <td style="white-space: normal;"><span style="white-space: normal;">低い</span></td>
          <td style="white-space: normal;"><span style="white-space: normal;">高い</span></td>
        </tr>
        <tr style="white-space: normal;">
          <td style="white-space: normal;"><span style="white-space: normal;">
          C++ バージョン</span></td>
          <td style="white-space: normal;"><span style="white-space: normal;">
          C++11〜</span></td>
          <td style="white-space: normal;"><span style="white-space: normal;">
          C++20〜</span></td>
        </tr>
    </table>
    </p>
	
    <p>&nbsp;</p>
  </section>
  	
  <p>&nbsp;</p>
  
  <section>
    <h2><a name="3._std::jthread_を使ってみる">3. std::jthread を使ってみる</a></h2>
    <p>まずは「<strong>stop_token</strong> による協調的キャンセル」の機能を試してみます。</p>
    <p>&nbsp;</p>
    
    <p>[環境]</p>
    <table>
    <tbody>
    	<tr>
    		<td class="td_separate" colspan="3"></td>
    	</tr>
    	
    	<tr>
    		<td>コンパイラ :</td>
    		<td>g++ (Ubuntu 13.3.0-6ubuntu2~24.04),</td>
    		<td>13.3.0</td>
    	</tr>
    	
    	<tr>
    		<td class="td_separate" colspan="3"></td>
    	</tr>
    	
    	<tr>
    		<td>OS: </td>
    		<td>Ubuntu 24.04 (WSL),</td>
    		<td></td>
    	</tr>
    	
    	<tr>
    		<td class="td_separate" colspan="3"></td>
    	</tr>
    </tbody>
    </table>
    
    <p> &nbsp;</p>
    
    <p> [プログラムソース] <span class="cpp-source">jthread_01.cpp</span></p>
    <pre class="prettyprint linenums lang-cpp" style="width:800px">
#include &lt;iostream&gt;     // cout, endl
#include &lt;cstdlib&gt;      // EXIT_SUCCESS
#include &lt;string&gt;       // string
#include &lt;chrono&gt;       // chrono
#include &lt;thread&gt;       // jthread
#include &lt;mutex&gt;        // mutex, lock_guard

// グローバルなミューテックス
std::mutex printMutex;

// スレッドセーフなメッセージ出力関数
void printMessage(const std::string&amp; message) {
    std::lock_guard&lt;std::mutex&gt; lock(printMutex);
    std::cout &lt;&lt; message &lt;&lt; std::endl;
}

// スレッド関数
void threadFunction( std::stop_token s, const std::string&amp; title ) {
    // 停止要求が来るまでループ
    while (!s.stop_requested()) {
        // 定期的にメッセージを出力
        printMessage("Thread is running: " + title);
        std::this_thread::sleep_for(std::chrono::seconds{1});
    }
    printMessage(title + " has received stop message.");
    std::this_thread::sleep_for(std::chrono::seconds{3});
    printMessage(title + " has been stopped.");
}

// メイン関数
int main(){
    // jthreadを使用して停止可能なスレッドを作成
    std::jthread worker{threadFunction, "[Thread A]"};
    // jthreadは自動的にスレッドをjoinするので、明示的なjoinは不要です。
    
    // メインスレッドも何か処理を行う
    for (int i = 0; i &lt; 3; ++i) {
        printMessage("Main thread is running: " + std::to_string(i));
        std::this_thread::sleep_for(std::chrono::seconds{3});
    }

    // スレッドに対して停止要求を送る
    worker.request_stop();
    printMessage("Stop request sent to worker thread.");

    // jthread はスコープを抜けると自動的に join されます
    // ここで worker.join() を呼ぶこともできますが、jthread は自動的に join されるため、通常は不要です
    return EXIT_SUCCESS;
}</pre>
    <p> &nbsp;</p>
    
    <p> ビルドおよび実行結果：</p>
    <pre class="prettyprint lang-bsh" style="width:800px">
$ g++ -std=c++20 -Wall -Wextra -Wpedantic -pthread -O2 jthread_sample_01.cpp -o jthread_sample_01.out
$ ./jthread_sample_01.out 
Main thread is running: 0
Thread is running: [Thread A]
Thread is running: [Thread A]
Thread is running: [Thread A]
Main thread is running: 1
Thread is running: [Thread A]
Thread is running: [Thread A]
Thread is running: [Thread A]
Main thread is running: 2
Thread is running: [Thread A]
Thread is running: [Thread A]
Thread is running: [Thread A]
Stop request sent to worker thread.
[Thread A] has received stop message.
[Thread A] has been stopped.
$ </pre>
    <p> &nbsp;</p>
    
    <table class="border-collapse" border="1" style="width: 800px">
      <caption>ビルドオプション説明：</caption>
      <thead class="standard_table">
        <tr>
          <th>オプション</th>
          <th>説明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="white-space: nowrap;"><strong>-std=c++20</strong></td>
          <td>C++20 標準でコンパイルします。言語機能（構文・ライブラリ仕様）が C++20 準拠になります。 </td>
        </tr>
        <tr>
          <td><strong>-Wall&nbsp;</strong></td>
          <td>一般的な警告群を有効にします。コード品質の初期チェックに有用です。 </td>
        </tr>
        <tr>
          <td><strong>-Wextra</strong></td>
          <td><strong>-Wall</strong>&nbsp;に含まれない追加の警告を有効にします。未使用パラメータなどを検出します。 </td>
        </tr>
        <tr>
          <td style="white-space: nowrap;"><strong>-Wpedantic</strong></td>
          <td>規格に厳格に従っていない拡張や非標準的記法を警告します。移植性を高めたい場合に有効です。 </td>
        </tr>
        <tr>
          <td><strong>-pthread</strong></td>
          <td>POSIX threads 
          のサポートを有効にし、スレッド関連のライブラリをリンクします。単に&nbsp;-lpthread&nbsp;をリンクするだけでなく、コンパイル時にスレッド対応（スレッドセーフな定義など）を有効にするフラグです。スレッド/ミューテックスなどを使うプログラムでは必須に近いオプションです（Linux）。 </td>
        </tr>
        <tr>
          <td><strong>-O2</strong></td>
          <td>最適化レベル 2 を指定します。実行速度向上のための最適化を行うが、"<strong>-O3</strong>" よりは穏やかで安定的な設定です。デバッグ時は 
          "<strong>-g -O0</strong>" 
          を推奨します。 </td>
        </tr>
      </tbody>
    </table>
    
    <p>&nbsp;</p>
    <p>スレッドへの停止要求を送ることで、スレッドを停止できることを確認できました。</p>
    <p>&nbsp;</p>
    
  </section>
  
  <p>&nbsp;</p>
  
  <section>
  	<h2> <a name="4._request_stop()_しないとどうなる？">4. request_stop() しないとどうなる？</a></h2>
  	<p> 起動中のスレッドに対して request_stop() しないでプログラムを終了した場合、どんな挙動になるのかを確認してみます。</p>
    <p> 結論から記載すると、jthread インスタンス解放時に自動的に request_stop() を発行してくれるようです。最初に記載の 特徴３ 
    になります。</p>
    <p> &nbsp;</p>
    <p> 前述の <span class="cpp-source">jthread_01.cpp</span> を元に作成するスレッドを３つに拡張したものを使用し、stop_request() 
    をコメントアウトしたサンプルプログラムを使用します。</p>
    <p> &nbsp;</p>
    
    <p>[環境]</p>
    <table>
    <tbody>
    	<tr>
    		<td class="td_separate" colspan="3"></td>
    	</tr>
    	
    	<tr>
    		<td>コンパイラ :</td>
    		<td>g++ (Ubuntu 13.3.0-6ubuntu2~24.04),</td>
    		<td>13.3.0</td>
    	</tr>
    	
    	<tr>
    		<td class="td_separate" colspan="3"></td>
    	</tr>
    	
    	<tr>
    		<td>OS: </td>
    		<td>Ubuntu 24.04 (WSL),</td>
    		<td></td>
    	</tr>
    	
    	<tr>
    		<td class="td_separate" colspan="3"></td>
    	</tr>
    </tbody>
    </table>
    
    <p> &nbsp;</p>
    
    <p> [プログラムソース] <span class="cpp-source">jthread_02.cpp</span></p>
    
    <pre class="prettyprint linenums lang-cpp" style="width:800px">
#include &lt;iostream&gt;     // cout, endl
#include &lt;cstdlib&gt;      // EXIT_SUCCESS
#include &lt;string&gt;       // string
#include &lt;chrono&gt;       // chrono
#include &lt;thread&gt;       // jthread
#include &lt;mutex&gt;        // mutex, lock_guard

// グローバルなミューテックス
std::mutex printMutex;

// スレッドセーフなメッセージ出力関数
void printMessage(const std::string&amp; message) {
    std::lock_guard&lt;std::mutex&gt; lock(printMutex);
    std::cout &lt;&lt; message &lt;&lt; std::endl;
}

// スレッド関数
void threadFunction( std::stop_token s, const std::string&amp; title ) {
    // 停止要求が来るまでループ
    while (!s.stop_requested()) {
        // 定期的にメッセージを出力
        printMessage("Thread is running: " + title);
        std::this_thread::sleep_for(std::chrono::seconds{1});
    }
    printMessage(title + " has received stop message.");
    std::this_thread::sleep_for(std::chrono::seconds{3});
    printMessage(title + " has been stopped.");
}

// メイン関数
int main(){
    // jthreadを使用して停止可能なスレッドを作成
    std::jthread worker1{threadFunction, "[Thread A]"};
    std::jthread worker2{threadFunction, "[Thread B]"};
    std::jthread worker3{threadFunction, "[Thread C]"};
    // jthreadは自動的にスレッドをjoinするので、明示的なjoinは不要です。
    
    // メインスレッドも何か処理を行う
    for (int i = 0; i &lt; 3; ++i) {
        printMessage("Main thread is running: " + std::to_string(i));
        std::this_thread::sleep_for(std::chrono::seconds{3});
    }

    // スレッドに対して停止要求を送る
    //worker1.request_stop();
    //worker2.request_stop();
    //worker3.request_stop();
    printMessage("Stop request sent to worker thread.");

    // jthreadはスコープを抜けると自動的にjoinされます
    // ここで worker.join() を呼ぶこともできますが、jthread は自動的に join されるため、通常は不要です
    return EXIT_SUCCESS;
}</pre>
    <p> &nbsp;</p>
    <p> ビルドおよび実行：</p>
    
    <pre class="prettyprint lang-bsh" style="width:800px">
$ g++ -std=c++20 -Wall -Wextra -Wpedantic -pthread -O2 jthread_sample_02.cpp -o jthread_sample_02.out
$ ./jthread_sample_02.out 
Main thread is running: 0
Thread is running: [Thread C]
Thread is running: [Thread B]
Thread is running: [Thread A]
Thread is running: [Thread A]
Thread is running: [Thread C]
Thread is running: [Thread B]
Thread is running: [Thread A]
Thread is running: [Thread C]
Thread is running: [Thread B]
Main thread is running: 1
Thread is running: [Thread A]
Thread is running: [Thread C]
Thread is running: [Thread B]
Thread is running: [Thread A]
Thread is running: [Thread C]
Thread is running: [Thread B]
Thread is running: [Thread A]
Thread is running: [Thread C]
Thread is running: [Thread B]
Main thread is running: 2
Thread is running: [Thread A]
Thread is running: [Thread C]
Thread is running: [Thread B]
Thread is running: [Thread A]
Thread is running: [Thread B]
Thread is running: [Thread C]
Thread is running: [Thread A]
Thread is running: [Thread B]
Thread is running: [Thread C]
Stop request sent to worker thread.
Thread is running: [Thread B]
[Thread C] has received stop message.
Thread is running: [Thread A]
Thread is running: [Thread B]
Thread is running: [Thread A]
Thread is running: [Thread B]
Thread is running: [Thread A]
[Thread C] has been stopped.
[Thread B] has received stop message.
Thread is running: [Thread A]
Thread is running: [Thread A]
Thread is running: [Thread A]
[Thread B] has been stopped.
[Thread A] has received stop message.
[Thread A] has been stopped.
$ </pre>
    <p> &nbsp;</p>
    <p> 全部のスレッドに対して自動的に request_stop() を発行してくれることを確認できました。</p>
    <p> ただし、コンソール出力内容を確認すると、まとめて全部に request_stop() を送信してくれるわけではなさそうです。一つずつ 
    request_stop() -&gt; join() しているようなので、プログラム終了後に恐らく以下と同等の処理をやってると思います。</p>
    
    <pre class="prettyprint linenums lang-cpp" style="width:800px">
    // スレッドに対して順番に停止要求を送り、その後 join() して終了を待つ
    {
        std::jthread* workers[] = { &amp;worker1, &amp;worker2, &amp;worker3 };
        for (std::jthread* w : workers) {
            printMessage("Sending stop request to a worker...");
            w-&gt;request_stop();
            // 停止処理が完了するのを待つ
            if (w-&gt;joinable()) {
                w-&gt;join();
                printMessage("Worker has been joined.");
            }
        }
    }</pre>
    
    <p> &nbsp;</p>
  </section>
	
  <p> &nbsp;</p>

  <section>
    <h2><a id="ライセンス">ライセンス</a></h2>
    <p>本ページの情報は、特記無い限り下記 MIT ライセンスで提供されます。</p>
    <div class="license">
      The MIT License (MIT)<br><br>
      
      &nbsp; Copyright 2026 Kinoshita Hidetoshi<br><br>
      
      Permission is hereby granted, free of charge, to any person obtaining a copy
      of this software and associated documentation files (the "Software"), to deal
      in the Software without restriction, including without limitation the rights
      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      copies of the Software, and to permit persons to whom the Software is
      furnished to do so, subject to the following conditions:<br><br>
      
      The above copyright notice and this permission notice shall be included in all
      copies or substantial portions of the Software.<br><br>
      
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      SOFTWARE.
    </div>
    <p>&nbsp;</p>
  </section>
  
  <p> &nbsp;</p>
  
  <section>
  	<h2><a id="参考">参考</a></h2>
  	<ul>
  		<li>
        <a href="https://en.cppreference.com/w/cpp/thread/jthread.html" target="_blank">
        std::jthread - cppreference.com</a></li>
      <li>
        <a href="https://cpprefjp.github.io/reference/thread/jthread.html" target="_blank">
        jthread - cpprefjp C++日本語リファレンス</a></li>
  	</ul>
  </section>
  
  <p>&nbsp;</p>
  <hr>
  <p>&nbsp;</p>
  
  <section>
  	<h2 style="margin-bottom:5px">変更履歴</h2>
  	<table>
  	  <tr>
  	    <td class="td_history_date">2026-02-04&nbsp;</td>
  	    <td class="td_history_separator">-</td>
  	    <td class="td_history">「<a href="#4._request_stop()_しないとどうなる？">4. request_stop() しないとどうなる？</a>」を追加</td>
  	  </tr>
  	  <tr>
  	    <td class="td_history_date">2026-02-01</td>
  	    <td class="td_history_separator">-</td>
  	    <td class="td_history">新規作成 </td>
  	  </tr>
  	</table>
  </section>
  
  <p>&nbsp;</p>
  
  <section>
    <p><a href="../../index.html" target="_parent">Programming Items トップページ</a></p>
    <p><a href="../../privacy_policy.html">プライバシーポリシー</a></p>
  </section>
  
  <p>&nbsp;</p>
  
  <footer>
  	<p><small>&copy; 2026 Kinoshita Hidetoshi (木下英俊)</small></p>
  </footer>
  
</body>
</html>
