<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="木下英俊">
  <meta name="description" content="木下英俊が自身のためにプログラムメモを残すことを目的に作成したページです。">
  <meta name="keywords" content="">
  <!-- キャッシュ無効化 -->
  <meta http-equiv="Cache-Control" content="no-cache">
  
  <!-- タイトル -->
  <title>std::unique_ptr | Programming Items</title>

  <!-- ファビコン -->
  <link rel="shortcut icon" href="../../favicon.ico">
  
  <!-- CSS -->
  <link href="https://unpkg.com/ress/dist/ress.min.css" rel="stylesheet">
	<link rel="stylesheet" href="../../design.css" type="text/css">
  
	<!-- Start for 'google-code-prettify' -->
  <link href="../../prettify/styles/desert.css" rel="stylesheet" type="text/css">
	<script src="../../prettify/prettify.js" type="text/javascript"></script>
	<!-- End for 'google-code-prettify' -->	

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-V2DZQK54C2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'G-V2DZQK54C2');
  </script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  
  <style type="text/css">
  .auto-style1 {
    background-color: #505000;
  }
  .auto-style2 {
    text-decoration: underline;
  }
  </style>
</head>

<body onload="prettyPrint();">

  <h1>std::unique_ptr (c++11)</h1>
  <p><strong><em>std::unique_ptr</em></strong> です。<span class="t-lines"><span><span class="t-mark"><strong><em>auto_ptr</em></strong> 
  が deprecated（廃止予定）になりましたので、今後は <a href="shared_ptr.html">shared_ptr</a>, <strong>
  <em>unique_ptr</em></strong> 
  がスマートポインタの主流になっていくことでしょう。<br><strong><em>auto_ptr</em></strong> の後継という意味では  
  <strong><em>unique_ptr</em></strong> の方がより近いかもしれません。</span></span></span></p>
  <p>unique_ptr は下記２つの形式をサポートします。</p>
  <ol>
    <li><span class="t-mark">template&lt;class T, class Deleter = 
    std::default_delete&lt;T&gt;&gt; class unique_ptr;</span></li>
    <li><span class="t-mark">template &lt;class T, class Deleter&gt; class 
    unique_ptr&lt;T[], Deleter&gt;;<br>⇨ 配列 T[] をサポートします。</span></li>
  </ol>
  <p>&nbsp;</p>

  <div class="mokuji">
    <nav>
      <h2>目次</h2>
      <p><a href="#1._unique_ptr_を使ってみる">1. unique_ptr を使ってみる</a></p>
      <p>&nbsp;&nbsp; <a href="#1-1._その1">1-1._その1</a></p>
      <p>&nbsp;&nbsp; <a href="#1-2._その2">1-2._その2</a></p>
      <p><a href="#2._関数の引数に使う">2._関数の引数に使う</a></p>
      <p>&nbsp;&nbsp; <a href="#2-1._その１">2-1._その１</a></p>
      <p><a href="#3. unique_ptr で動的配列を使う">3. unique_ptr で動的配列を使う</a></p>
      <p><a href="#4._malloc,_free_を_unique_ptr_に置き換える">4. malloc, free を unique_ptr に置き換える</a></p>
      <p><a href="#5. fopen, fclose を unique_ptr に置き換える">5. fopen, fclose を unique_ptr に置き換える</a></p>
      <p><a href="#6._make_unique">6. make_unique</a></p>
      <p><a href="#7._make_unique_配列版">7. make_unique 配列版</a></p>
      <p>&nbsp;&nbsp; <a href="#7-1._1次元配列">7-1._1次元配列</a></p>
      <p>&nbsp;&nbsp; <a href="#7-2._2次元配列">7-2._2次元配列</a></p>
      <p>&nbsp;&nbsp; <a href="#7-3._3次元配列">7-3._3次元配列</a></p>
      <p>&nbsp;</p>
      <p><a href="#ライセンス">ライセンス</a></p>
      <p><a href="#参考">参考</a></p>
    </nav>
  </div>

  <p>&nbsp;</p>
  <p>&nbsp;</p>

  <section>
    <h2><a name="1._unique_ptr_を使ってみる">1. unique_ptr を使ってみる</a></h2>
    <p>まずは <strong><em>unique_ptr</em></strong> を使ってみます。<strong><em>shared_ptr</em></strong> 
    とほとんど同じ感じで使用できますが、コピーはできません。moveを使って管理者の譲渡と明示的に行う必要があります。</p>
    <p>&nbsp;</p>
    
    <section>
      <h3><a name="1-1._その1">1-1. その1</a></h3>
      <p>最初にシンプルな unique_ptr 使用例を紹介します。</p>
      <p>&nbsp;</p>
      <p><strong>unique_ptr</strong> を直接使用する例を記載します。</p>
      <p>int 型の生成は、以下のように使用します。</p>
      <pre class="prettyprint lang-cpp" style="width:800px">std::unique_ptr<int> up(new int);</pre>
      <p>&nbsp;</p>
      <p>値の初期化を一緒に行いたい場合、以下のように使用します。下記例は 10 で初期化しています。 </p>
      <pre class="prettyprint lang-cpp" style="width:800px">std::unique_ptr<int> up(new int(10));</pre>
      <p>&nbsp;</p>
      <p>配列を確保する場合は、以下のように使用します。</p>
      <pre class="prettyprint lang-cpp" style="width:800px">std::unique_ptr<int[]> arr_up(new int[5]);</pre>
      <p>&nbsp;</p>
      <p>配列の値を初期化と一緒に行いたい場合、以下のように使用します。下記例は {1,2,3,4,5} で初期化しています。 </p>
      <pre class="prettyprint lang-cpp" style="width:800px">std::unique_ptr<int[]> arr_up(new int[5]{1,2,3,4,5});</pre>
      <p>&nbsp;</p>
      <p><strong>make_unique</strong> による例を記載します。</p>
      
      <p>int 型の生成は、以下のように使用します。</p>
      <pre class="prettyprint lang-cpp" style="width:800px">auto up = std::make_unique&lt;int&gt;();</pre>
      <p>&nbsp;</p>
      
      <p>値の初期化を一緒に行いたい場合、以下のように使用します。下記例は 77 で初期化しています。 </p>
      <pre class="prettyprint lang-cpp" style="width:800px">auto up = std::make_unique&lt;int&gt;(77);</pre>
      <p>&nbsp;</p>
      
      <p>配列を確保する場合、以下のように使用します。下記例では、配列数 5 です。<br>make_unique を使って初期化を一緒に行うことはできないようです。</p>
      <pre class="prettyprint lang-cpp" style="width:800px">
auto arr_up = std::make_unique&lt;int[]&gt;(5); // 要素はデフォルト初期化（ゼロでない場合あり）
for (int i = 0; i &lt; 5; ++i) {
    arr_up[i] = (i + 1) * 10;
}</pre>
      <p>&nbsp;</p>
      <p>&nbsp;</p>
      <p>上記内容を含む c++ プログラムを以下で紹介します。</p>
      <p>&nbsp;</p>
      <p>ソースコード：</p>
      <p>["unique_ptr_01.cpp"]</p>
      
      <pre class="prettyprint linenums lang-cpp" style="width:800px">
#include &lt;iostream&gt;     // for std::cout
#include &lt;new&gt;          // for std::nothrow, placement new
#include &lt;memory&gt;       // for std::make_unique
 
/**
 * @brief std::unique_ptr, std::make_unique のシンプルなサンプル
 */
 
int main() {
    std::cout &lt;&lt; "-- uqique_ptr simple examples start --\n";

    // 1) 単一 int の std::unique_ptr
    {
        std::unique_ptr&lt;int&gt; up(new int(10));
        std::cout &lt;&lt; "*up = " &lt;&lt; *up &lt;&lt; "\n";
        // delete は自動的に行われる
    }

    // 2) int 配列の std::unique_ptr
    {
        std::unique_ptr&lt;int[]&gt; arr_up(new int[5]{1,2,3,4,5});
        for (int i = 0; i &lt; 5; ++i) {
            std::cout &lt;&lt; "arr_up[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; arr_up[i] &lt;&lt; "\n";
        }
        // delete[] は自動的に行われる
    }

    // 3) 単一 int 生成、std::make_unique 版
    {
        auto up = std::make_unique&lt;int&gt;(77);
        std::cout &lt;&lt; "unique_ptr owns = " &lt;&lt; *up &lt;&lt; "\n";
        // delete は自動的に行われる
    }

    // 4) 配列 int 生成、std::make_unique 配列版（C++14 以降）
    {
        auto arr_up = std::make_unique&lt;int[]&gt;(5); // 要素はデフォルト初期化（ゼロでない場合あり）
        for (int i = 0; i &lt; 5; ++i) {
            arr_up[i] = (i + 1) * 10;
        }
        std::cout &lt;&lt; "make_unique&lt;int[]&gt; contents:";
        for (int i = 0; i &lt; 5; ++i) {
            std::cout &lt;&lt; ' ' &lt;&lt; arr_up[i];
        }
        std::cout &lt;&lt; '\n';
        // delete[] は自動的に行われる
    }

    std::cout &lt;&lt; "-- uqique_ptr simple examples end --\n";
    return 0;
}</pre>

      <p>&nbsp;</p>
      
      <p>ビルド方法：</p>
      <pre class="prettyprint lang-bsh" style="width:800px">g++ -std=c++17 -Wall -Wextra -Wpedantic -O2 unique_ptr_01.cpp -o unique_ptr_01.out</pre>
      
      <p>&nbsp;</p>
      <p>実行結果：</p>
      
      <pre class="prettyprint lang-bsh" style="width:800px">
$ ./unique_ptr_01.out 
-- uqique_ptr simple examples start --
*up = 10
arr_up[0] = 1
arr_up[1] = 2
arr_up[2] = 3
arr_up[3] = 4
arr_up[4] = 5
unique_ptr owns = 77
make_unique&lt;int[]&gt; contents: 10 20 30 40 50
-- uqique_ptr simple examples end --
$ </pre>

      <p>&nbsp;</p>
    </section>
    
    <p>&nbsp;</p>
    
    <section>
      <h3><a name="1-2._その2">1-2. その2</a></h3>
      <p>前の節で unique_ptr の簡単な使用方法について記載しました。</p>
      <p>でも「本当に解放処理を自動的にやってくれてるのか心配」ですよね。</p>
      <p>本節では、unique_ptr で class インスタンスを生成して、delete 
      無しで自動的にデストラクタが実行されることを確認してみます。</p>
      <p>&nbsp;</p>
    	<h4>[環境]</h4>
    	<table>
      	<tbody>
      	  <tr>
      	    <td class="td_separate" colspan="3"></td>
      	  </tr>
      		
      	  <tr>
      	    <td>コンパイラ :</td>
      	      <td>g++ (Ubuntu 13.3.0-6ubuntu2~24.04), </td>
      	      <td>13.3.0</td>
      	  </tr>
      		
      	  <tr>
      	    <td class="td_separate" colspan="3"></td>
      	  </tr>
      		
      	  <tr>
      	    <td>OS :</td>
      	    <td>Ubuntu 24.04 (WSL)</td>
      	    <td>&nbsp;</td>
      	  </tr>
      	  
      	  <tr>
      	    <td class="td_separate" colspan="3"></td>
      	  </tr>
      	</tbody>
    	</table>

      <p>&nbsp;</p>
      <p>[ソースコード： "unique_ptr.cpp"]</p>
      
      <pre class="prettyprint linenums lang-cpp" style="width:800px">
#include &lt;iostream&gt;     // cout, endl
#include &lt;string&gt;       // string
#include &lt;memory&gt;       // unique_ptr
#include &lt;cstdlib&gt;      // EXIT_SUCCESS

class Person {
private:
    std::string name_;
    std::string phone_;

public:
    /**
     * @brief デフォルトコンストラクタ
     *        空の名前と電話番号で委譲コンストラクタを呼ぶ
     */
    Person()
        : Person("", "")                // 委譲コンストラクタ
    {
    }

    /**
     * @brief コピーコンストラクタ
     * @param rhs コピー元
     */
    Person(const Person&amp; rhs)
        : Person(rhs.name_, rhs.phone_)
    {
    }

    /**
     * @brief 値を指定するコンストラクタ
     * @param name 氏名
     * @param phone 電話番号
     */
    Person(const std::string&amp; name, const std::string&amp; phone)
        : name_(name), phone_(phone)
    {
        std::cout &lt;&lt; "Person::Person()" &lt;&lt; std::endl;
    }

    /**
     * @brief デストラクタ
     */
    virtual ~Person()
    {
        std::cout &lt;&lt; "Person::~Person()" &lt;&lt; std::endl;
    }

    /**
     * @brief 名前を取得する
     * @return 名前への参照
     */
    const std::string&amp; getName() const
    {
        return name_;
    }

    /**
     * @brief 電話番号を取得する
     * @return 電話番号への参照
     */
    const std::string&amp; getPhone() const
    {
        return phone_;
    }
};


// Person を出力する演算子オーバーロード
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Person&amp; p)
{
    return (os &lt;&lt; '(' &lt;&lt; p.getName() &lt;&lt; ',' &lt;&lt; p.getPhone() &lt;&lt; ')');
}

/**
 * @brief Person をコンソール出力する（null 安全）
 * @param person 出力対象の unique_ptr
 */
void coutPerson(const std::unique_ptr&lt;Person&gt;&amp; person)
{
    if (person) {
        std::cout &lt;&lt; *person &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "(null)" &lt;&lt; std::endl;
    }
}

/**
 * @brief unique_ptr が指す Person を差し替える（所有権は引数で渡された参照側に残る）
 * @param person 差し替え対象の unique_ptr への参照
 */
void replacePerson(std::unique_ptr&lt;Person&gt;&amp; person)
{
    person = std::make_unique&lt;Person&gt;("bar_2", "090-****-????");
}

int main()
{
    // unique_ptr 生成
    std::unique_ptr&lt;Person&gt; foo = std::make_unique&lt;Person&gt;("foo", "090-****-0123");
    std::unique_ptr&lt;Person&gt; bar = std::make_unique&lt;Person&gt;("bar", "090-****-5555");
    std::unique_ptr&lt;Person&gt; hoge;

    // コンソール出力
    coutPerson(foo);        // (foo,090-****-0123)
    coutPerson(bar);        // (bar,090-****-5555)
    coutPerson(hoge);       // (null)

    // Person 差し替え
    replacePerson(bar);
    coutPerson(bar);        // (bar_2,090-****-????)

    // 所有権の移動
    hoge = std::move(foo);
    // hoge = foo;          // これはコンパイルエラーになる
    coutPerson(foo);        // (null)
    coutPerson(hoge);       // (foo,090-****-0123)

    return EXIT_SUCCESS;
}</pre>

      <p>&nbsp;</p>
      
      <p>ビルド(例)：</p>
      <pre class="prettyprint" style="width:800px">
$ g++ -Wall -g make_unique.cpp -o make_unique.out</pre>

      <p>&nbsp;</p>
    
      <p>実行結果：</p>
      <pre class="prettyprint" style="width:800px">
$ ./make_unique.out 
Person::Person()
Person::Person()
(foo,090-****-0123)
(bar,090-****-5555)
(null)
Person::Person()
Person::~Person()
(bar_2,090-****-????)
(null)
(foo,090-****-0123)
Person::~Person()
Person::~Person()
$ </pre>
      <p>&nbsp;</p>
      <p>3箇所でクラス Person のデストラクタが実行されている（"Person::~Person()" 
      の部分）ことから、unique_ptr が期待通りに解放処理を行っていることがわかります。</p>
      <p>&nbsp;</p>
      
    </section>    
  </section>

  <p>&nbsp;</p>
  
  <section>
    <h2><a name="2._関数の引数に使う">2. 関数の引数に使う</a></h2>
    <p><strong>std::unique_ptr</strong> を関数の引数に使用する例を紹介します。</p>
    <p>&nbsp;</p>
    
    <section>
      <h3><a name="2-1._その１">2-1. その１</a></h3>
      <p>関数の引数に <strong>unique_ptr</strong> を渡してみます。</p>
      <p>関数に <strong>unique_ptr</strong> を渡したり、関数の中で <strong>unique_ptr</strong> 
      の値を変更したり、といったことができます。 </p>
      <p>&nbsp;</p>
      <p>［ソースコード： "function_argument_sample.cpp"]</p>
      
      <pre class="prettyprint linenums lang-cpp" style="width:800px">
#include &lt;iostream&gt; // for std::cout
#include &lt;memory&gt;   // for std::unique_ptr
#include &lt;string&gt;   // for std::string

/**
 * @brief 簡易的な Person クラス（サンプル用）
 */
class Person {
private:
    std::string name_;
    std::string phone_;

public:
    Person(const std::string&amp; name, const std::string&amp; phone)
        : name_(name), phone_(phone) {}

    const std::string&amp; getName() const { return name_; }
    const std::string&amp; getPhone() const { return phone_; }
};

/**
 * @brief unique_ptr を読み取り専用で受け取り内容を表示する
 * @param person コンテンツを参照する const 参照の unique_ptr
 */
void inspect(const std::unique_ptr&lt;Person&gt;&amp; person)
{
    if (person) {
        std::cout &lt;&lt; "inspect: " &lt;&lt; person-&gt;getName() &lt;&lt; ", " &lt;&lt; person-&gt;getPhone() &lt;&lt; "\n";
    } else {
        std::cout &lt;&lt; "inspect: (null)\n";
    }
}

/**
 * @brief unique_ptr の参照を受け取り差し替える（所有権は呼び出し元に残る）
 * @param person 差し替える対象の unique_ptr への参照
 */
void resetByRef(std::unique_ptr&lt;Person&gt;&amp; person)
{
    person = std::make_unique&lt;Person&gt;("replaced", "000-0000-0000");
}

/**
 * @brief 値渡しで unique_ptr を受け取り所有権を取得する
 * @param person 所有権を移動して受け取る unique_ptr
 */
void takeOwnership(std::unique_ptr&lt;Person&gt; person)
{
    if (person) {
        std::cout &lt;&lt; "takeOwnership: received " &lt;&lt; person-&gt;getName() &lt;&lt; "\n";
    } else {
        std::cout &lt;&lt; "takeOwnership: (null)\n";
    }
    // person はここでスコープを抜けると破棄される
}

/**
 * @brief Person を生成して所有権を返すファクトリ関数
 * @param name 氏名
 * @param phone 電話番号
 * @return 所有権を持つ unique_ptr&lt;Person&gt;
 */
std::unique_ptr&lt;Person&gt; makePerson(const std::string&amp; name, const std::string&amp; phone)
{
    return std::make_unique&lt;Person&gt;(name, phone);
}

int main()
{
    std::cout &lt;&lt; "-- unique_ptr function argument sample start --\n";

    // 1) makePerson で生成して戻り値で受け取る
    auto p1 = makePerson("alice", "111-1111-1111");
    inspect(p1);

    // 2) resetByRef で参照を渡して差し替える
    resetByRef(p1);
    inspect(p1);

    // 3) takeOwnership に値渡しで渡す（move を使う）
    auto p2 = makePerson("bob", "222-2222-2222");
    takeOwnership(std::move(p2));
    inspect(p2); // p2 は null になっている

    // 4) inspect に null を渡す
    std::unique_ptr&lt;Person&gt; empty;
    inspect(empty);

    std::cout &lt;&lt; "-- unique_ptr function argument sample end --\n";
    return 0;
}</pre>
      <p>&nbsp;</p>
      
      <p>ビルド方法（g++）：</p>
      <pre class="prettyprint lang-bsh" style="width:800px">g++ -std=c++23 -O2 -Wall -Wextra -Wpedantic function_argument_sample.cpp -o function_argument_sample.out</pre>
      <p>&nbsp;</p>
      
      <p>実行結果：</p>
      <pre class="prettyprint lang-bsh" style="width:800px">
$ ./function_argument_sample.out 
-- unique_ptr function argument sample start --
inspect: alice, 111-1111-1111
inspect: replaced, 000-0000-0000
takeOwnership: received bob
inspect: (null)
inspect: (null)
-- unique_ptr function argument sample end --
$ </pre>
      <p>&nbsp;</p>
    </section>
  </section>

  <p>&nbsp;</p>
      
  <section>
    <h2><a name="3. unique_ptr で動的配列を使う">3. unique_ptr で動的配列を使う</a></h2>
    <p><strong><em>unique_ptr</em></strong> で動的配列を使用する例です。<br>T[]の特殊化が組み込まれており、[]演算子も実装されています。直観的で気持ちよく使えます。<br>
    ただし範囲外アクセスに対するチェック機構はありません。配列を使用したい場合、まずはコンテナの使用を検討するべきです。時々実行速度を問題にコンテナの使用を止めている場合がありますが、C++11で採用された 
    std::array を使用すれば処理速度の問題もありません。</p>
    
    <pre class="prettyprint linenums lang-cpp" style="width:800px">
#include &lt;iostream&gt;         // cout, endl, EXIT_SUCCESS
#include &lt;string&gt;           // string
#include &lt;memory&gt;           // unique_ptr

using namespace std;

int main(int argc, char* argv[])
{
    // std::unique_ptr の例
    // default_delete の特殊化宣言は不要。delete[]が実行される。
    // []演算子もある。
    size_t  n = 10;
    std::<span class="auto-style1">unique_ptr</span>&lt;int[]&gt; data(new int[n]);

    cout &lt;&lt; "std::unique_ptr&lt;int&gt; : ";
    for (size_t i = 0; i &lt; n; ++i){
        data[i] = i;
    }
    for (size_t i = 0; i &lt; n; ++i){
        cout &lt;&lt; data[i] &lt;&lt; <span class="string">" "</span>;
    }
    cout &lt;&lt; endl;

    return EXIT_SUCCESS;
}</pre>

    <p>&nbsp;</p>
  </section>
  
  <p>&nbsp;</p>
  
  <section>
    <h2><a name="4._malloc,_free_を_unique_ptr_に置き換える">4. malloc, free を unique_ptr に置き換える</a></h2>
    
    <p>c 言語で規定されている malloc, calloc でメモリを動的に取得した場合、解放に使用する関数は delete や delete[] ではなく 
    free を使用します。デアロケータを指定することで unique_ptr のメモリ解放を free で行えるようにします。</p>
    
    <pre class="prettyprint linenums lang-cpp">
#include &lt;iostream&gt;     // cout, EXIT_SUCCESS
#include &lt;memory&gt;       // shared_ptr, unique_ptr
#include &lt;cstdlib&gt;      // malloc, free

using namespace std;

int main()
{
    const size_t    n = 256;

    // unique_ptr&lt;int[]&gt;
    std::<span class="auto-style1">unique_ptr</span>&lt;int[], decltype(&amp;free)&gt; memory(static_cast&lt;int*&gt; (malloc(n*sizeof(int))), std::free);    // &quot;decltype(&amp;free)&quot; は &quot;void(*)(void*)&quot; となるみたい
    // std::<span class="auto-style1">unique_ptr</span>&lt;int[], void(*)(void*)&gt; memory(static_cast&lt;int*&gt; (malloc(n*sizeof(int))), std::free);  // だからこちらでもOK

    if (memory.get()==nullptr){
        // malloc失敗
    }
    else{
        // malloc成功
        for (size_t i = 0; i &lt; n; ++i){
            memory[i] = (int)i;
        }
        for (size_t i = 0; i &lt; n; ++i){
            cout &lt;&lt; memory[i] &lt;&lt; ", ";
        }
        cout &lt;&lt; endl;
    }

    return EXIT_SUCCESS;
}</pre>

    <p>&nbsp;</p>
  </section>

  <p>&nbsp;</p>

  <section>
    <h2><a name="5. fopen, fclose を unique_ptr に置き換える">5. fopen, fclose を unique_ptr 
    に置き換える</a></h2>
    <p>これは実装例をいくつか書いてみます。しっくりくるやつを使ってみてください。</p>

    <section>
      <h3>5-1. シンプルな実装例</h3>
      <p>シンプルにやるとこんな感じでしょうか。</p>

      <pre class="prettyprint linenums lang-cpp" style="width:800px">
#include &lt;stdio.h&gt;  <span class="comment">// fopen, fclose</span>
#include &lt;stdlib.h&gt;
#include &lt;memory&gt;   <span class="comment">// unique_ptr</span>

#pragma warning(disable : 4996) <span class="comment">// fopen, fclose の使用がエラーになるため</span>

void custom_fclose(FILE* fp){
    if (fp != nullptr){
        fclose(fp);
    }
}

int main(int argc, char* argv[])
{
<span class="auto-style1">    std::unique_ptr&lt;FILE, decltype(&amp;custom_fclose)&gt;   fp(fopen("fopen_test.txt", "w"), custom_fclose);</span>
<span class="auto-style1">    // std::unique_ptr&lt;FILE, void(*)(FILE*)&gt;   fp(fopen("fopen_test.txt", "w"), custom_fclose);</span>

    if (fp.get() != nullptr){
        // fopen成功
        fprintf(fp.get(), "test\n");
    }

    return EXIT_SUCCESS;
    // ここで custom_fclose が自動実行されます
}</pre>

      <p>&nbsp;</p>
    </section>

    <p>&nbsp;</p>

    <section>
      <h3>5-2. Lambda式 による実装例</h3>
      <p>Lambda式 で記載するとこんな感じでしょうか。</p>

      <pre class="prettyprint linenums lang-cpp" style="width:800px">
#include &lt;stdio.h&gt;          // FILE, fopen, fclose
#include &lt;stdlib.h&gt;
#include &lt;memory&gt;           // unique_ptr

#pragma warning(disable : 4996)

int main(int argc, char* argv[])
{
<span class="auto-style1">    std::unique_ptr&lt;FILE, void(*)(FILE*)&gt;   fp(fopen("fopen_test.txt", "w"), [&amp;](FILE* fp){</span>
<span class="auto-style1">        if (fp != nullptr){</span>
<span class="auto-style1">            fclose(fp);</span>
<span class="auto-style1">        }</span>
<span class="auto-style1">    });</span>

    // 一応ファイルオープンの成功/失敗を確認してからファイルを使用
    if (fp.get() != nullptr){
        // fopen成功
        fprintf(fp.get(), "test\n");
    }

    return EXIT_SUCCESS;
    // ここで custom_fclose が自動実行されます
}</pre>

      <p>&nbsp;</p>

    </section>

    <p>&nbsp;</p>

    <section>      
      <h3>5-3. ファクトリーパターン による実装例</h3>
      <p>ファクトリーパターン的に unique_ptr を返す関数を作成するならばこんな感じでしょうか。</p>

      <pre class="prettyprint linenums">
<code>#include &lt;cstdio&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // fopen, fclose
#include &lt;iostream&gt;&nbsp;&nbsp;&nbsp;&nbsp; // cout, EXIT_SUCCESS
#include &lt;memory&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // unique_ptr

using namespace std;

#pragma warning(disable : 4996)

std::<span class="auto-style1">unique_ptr</span>&lt;std::FILE, void(*)(FILE*)&gt; make_file(const char * filename, const char * flags)
{
&nbsp;&nbsp;&nbsp; // fclose に NULL を渡して実行してはいけない。
&nbsp;&nbsp;&nbsp; // このため下記のような分岐処理が必要となる。
&nbsp;&nbsp;&nbsp; std::FILE * const fp = std::fopen(filename, flags);
&nbsp;&nbsp;&nbsp; <span class="auto-style2">return fp ? std::<span class="auto-style1">unique</span></span>_ptr<span class="auto-style2">&lt;std::FILE<font face="Meiryo UI"><code>, void(*)(FILE*)</code></font>&gt;(fp, std::fclose) : std::<span class="auto-style1">unique_ptr</span>&lt;std::FILE<font face="Meiryo UI"><code>, void(*)(FILE*)</code></font>&gt;();</span>
}

int main()
{
&nbsp;&nbsp;&nbsp; auto fp = make_file("hello.txt", "wb");

&nbsp;&nbsp;&nbsp; // fp.get() をチェック
&nbsp;&nbsp;&nbsp; // fopen に失敗していたら fp.get() は NULL
&nbsp;&nbsp;&nbsp; if (fp.get()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(fp.get(), "Hello world.");
&nbsp;&nbsp;&nbsp; }
}</code></pre>

      <p>私的には Lambda式 を使った2番目のやつが一番シンプルで好きかな。</p>
      <p>&nbsp;</p>
    </section>

  </section>

  <p>&nbsp;</p>

  <section>
    <h2><a name="6._make_unique">6. make_unique</a></h2>
    
    <p>c++14 から <strong>make_unique</strong> が加わりました。<strong>unique_ptr</strong> 直接使用せず 
     
    <strong>make_unique</strong> によるコーディングが推奨されています。</p>
    <p>&nbsp;</p>
    <p>[ソースコード： "make_shared_01.cpp"]</p>
    
    <pre class="prettyprint linenums lang-cpp" style="width:800px">
#include &lt;iostream&gt;     // for std::cout
#include &lt;new&gt;          // for std::nothrow, placement new
#include &lt;memory&gt;       // for std::make_unique

/**
 * @brief std::make_shared のシンプルなサンプル
 */

int main() {
    std::cout &lt;&lt; "-- make_unique simple examples start --\n";

    // 1) 単一 int 生成、std::make_unique 版
    {
        auto up = std::make_unique&lt;int&gt;();
        std::cout &lt;&lt; "make_unique owns = " &lt;&lt; *up &lt;&lt; "\n";
        // delete は自動的に行われる
    }

    // 2) 単一 int 生成、std::make_unique 版
    {
        auto up = std::make_unique&lt;int&gt;(77);
        std::cout &lt;&lt; "make_unique owns = " &lt;&lt; *up &lt;&lt; "\n";
        // delete は自動的に行われる
    }

    std::cout &lt;&lt; "-- make_unique simple examples end --\n";
   return 0;
}</pre>
    <p>&nbsp;</p>
    <p>ビルド方法：</p>
    <pre class="prettyprint lang-bsh" style="width:800px">g++ -std=c++20 -g -Wall -Wextra -Wpedantic make_unique_01.cpp -o make_unique_01.out</pre>
    <p>&nbsp;</p>
    <p>実行結果：</p>
    <pre class="prettyprint lang-bsh" style="width:800px">
$ ./make_shared_01.out 
-- shared_ptr simple examples start --
shared_ptr owns = 0
shared_ptr owns = 77
-- shared_ptr simple examples end --
$ </pre>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>class インスタンスの生成もやってみます。</p>
    <p>&nbsp;</p>
    
    <p>[ソースコード： "make_unique_02.cpp"]</p>
    
    <pre class="prettyprint linenums lang-cpp" style="width:800px">
#include &lt;iostream&gt;     // cout, endl
#include &lt;string&gt;       // string
#include &lt;memory&gt;       // unique_ptr
#include &lt;cstdlib&gt;      // EXIT_SUCCESS

class Person {
private:
    std::string name_;
    std::string phone_;

public:
    /**
     * @brief デフォルトコンストラクタ
     *        空の名前と電話番号で委譲コンストラクタを呼ぶ
     */
    Person()
        : Person("", "")                // 委譲コンストラクタ
    {
    }

    /**
     * @brief コピーコンストラクタ
     * @param rhs コピー元
     */
    Person(const Person&amp; rhs)
        : Person(rhs.name_, rhs.phone_)
    {
    }

    /**
     * @brief 値を指定するコンストラクタ
     * @param name 氏名
     * @param phone 電話番号
     */
    Person(std::string name, std::string phone)
        : name_(std::move(name)), phone_(std::move(phone))
    {
        std::cout &lt;&lt; "Person::Person()" &lt;&lt; std::endl;
    }

    /**
     * @brief デストラクタ
     */
    virtual ~Person()
    {
        std::cout &lt;&lt; "Person::~Person()" &lt;&lt; std::endl;
    }

    /**
     * @brief 名前を取得する
     * @return 名前への参照
     */
    const std::string&amp; getName() const
    {
        return name_;
    }

    /**
     * @brief 電話番号を取得する
     * @return 電話番号への参照
     */
    const std::string&amp; getPhone() const
    {
        return phone_;
    }
};


// Person を出力する演算子オーバーロード
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Person&amp; p)
{
    return (os &lt;&lt; '(' &lt;&lt; p.getName() &lt;&lt; ',' &lt;&lt; p.getPhone() &lt;&lt; ')');
}

/**
 * @brief Person をコンソール出力する（null 安全）
 * @param person 出力対象の unique_ptr
 */
void coutPerson(const std::unique_ptr&lt;Person&gt;&amp; person)
{
    if (person) {
        std::cout &lt;&lt; *person &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "(null)" &lt;&lt; std::endl;
    }
}

/**
 * @brief unique_ptr が指す Person を差し替える（所有権は引数で渡された参照側に残る）
 * @param person 差し替え対象の unique_ptr への参照
 */
void replacePerson(std::unique_ptr&lt;Person&gt;&amp; person)
{
    person = std::make_unique&lt;Person&gt;("bar_2", "090-****-????");
}

int main()
{
    // unique_ptr 生成
    std::unique_ptr&lt;Person&gt; foo = std::make_unique&lt;Person&gt;("foo", "090-****-0123");
    std::unique_ptr&lt;Person&gt; bar = std::make_unique&lt;Person&gt;("bar", "090-****-5555");
    std::unique_ptr&lt;Person&gt; hoge;

    // コンソール出力
    coutPerson(foo);        // (foo,090-****-0123)
    coutPerson(bar);        // (bar,090-****-5555)
    coutPerson(hoge);       // (null)

    // Person 差し替え
    replacePerson(bar);
    coutPerson(bar);        // (bar_2,090-****-????)

    // 所有権の移動
    hoge = std::move(foo);
    // hoge = foo;          // これはコンパイルエラーになる
    coutPerson(foo);        // (null)
    coutPerson(hoge);       // (foo,090-****-0123)

    return EXIT_SUCCESS;
}</pre>

    <p>&nbsp;</p>
    
    <p>ビルド(例)：</p>
    <pre class="prettyprint" style="width:800px">
$ g++ -Wall -Wextra -Wpedantic -g make_unique_02.cpp -o make_unique_02.out</pre>

    <p>&nbsp;</p>
    
    <p>実行結果：</p>
    <pre class="prettyprint" style="width:800px">
$ ./make_unique_02.out 
Person::Person()
Person::Person()
(foo,090-****-0123)
(bar,090-****-5555)
(null)
Person::Person()
Person::~Person()
(bar_2,090-****-????)
(null)
(foo,090-****-0123)
Person::~Person()
Person::~Person()
$ </pre>

    <p>&nbsp;</p>
    
  </section>
    
  <p>&nbsp;</p>

  <section>
  
    <h2><a name="7._make_unique_配列版">7. make_unique 配列版</a></h2>
    <p>c++14 で追加された <strong>make_unique</strong> は T[] および T[N] に対応しています。<br>unique_ptr 
    を使用する場合、いろいろな理由から <strong>make_unique</strong> を使用することが推奨みたいです。</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    
    <section>
      <h3><a name="7-1._1次元配列">7-1. 1次元配列</a></h3>
      <p>1次元配列を扱う例を記載します。</p>
      <p>&nbsp;</p>

      <p>[ソースコード： "make_unique_03.cpp"]</p>

      <pre class="prettyprint linenums lang-cpp" style="width:800px">
#include &lt;iostream&gt;     // for std::cout
#include &lt;new&gt;          // for std::nothrow, placement new
#include &lt;memory&gt;       // for std::make_shared

/**
 * @brief std::shared_ptr, std::make_shared のシンプルなサンプル
 */

int main() {
    std::cout &lt;&lt; "-- make_unique simple examples start --\n";

    // 1) 配列 int 生成、std::make_shared 配列版（C++20 以降）
    {
        const size_t array_size = 5;
        auto arr_up = std::make_unique&lt;int[]&gt;(array_size);   // 要素はデフォルト初期化（ゼロでない場合あり）
        for (size_t i = 0; i &lt; array_size; ++i) {
            arr_up[i] = (i + 1) * 10;
        }

        std::cout &lt;&lt; "make_shared&lt;int[]&gt; contents: ";
        for (size_t i = 0; i &lt; array_size; ++i) {
            std::cout &lt;&lt; ' ' &lt;&lt; arr_up[i];
        }
        std::cout &lt;&lt; '\n';
        // delete[] は自動的に行われる
    }

    std::cout &lt;&lt; "-- make_unique simple examples end --\n";
   return 0;
}</pre>

      <p>&nbsp;</p>
      
      <p>ビルド例：</p>
      <pre class="prettyprint" style="width:800px">
$ g++ -Wall -Wextra -Wpedantic -g make_unique_03.cpp -o make_unique_03.out</pre>

      <p>&nbsp;</p>
      <p>実行結果：</p>
      <pre class="prettyprint" style="width:800px">
$ ./make_unique_03.out
-- make_unique simple examples start --
make_shared<int[]> contents:  10 20 30 40 50
-- make_unique simple examples end --$ </pre>
      <p>&nbsp;</p>
    
      <p>&nbsp;</p>
      <p>class インスタンスを make_unique で1次元配列にする例も作成してみましょう。</p>
      <p>&nbsp;</p>

      <p>[ソースコード： "make_unique_04.cpp"]</p>
      <pre class="prettyprint linenums lang-cpp" style="width:800px">
#include &lt;iostream&gt;     // for std::cout
#include &lt;memory&gt;       // for std::make_unique
#include &lt;string&gt;
#include &lt;cstdlib&gt;      // for EXIT_SUCCESS

// class Person
class Person {
private:
    std::string  name_;
    std::string  phone_;

public:
    Person()
        : Person("", "")                    // 委譲コンストラクタ
    {
    }
    
    // コピーコンストラクタ
    Person(const Person&amp; rhs)               // コピーコンストラクタ
        : Person(rhs.name_, rhs.phone_)     // 委譲コンストラクタ
    {
    }
    
    Person(const std::string&amp; name, const std::string&amp; phone)
        : name_(name), phone_(phone)
    {
        std::cout &lt;&lt; "Person::Person(), name_ = " &lt;&lt; name_ &lt;&lt; std::endl;
    }

    // デストラクタ
    virtual ~Person()
    {
        std::cout &lt;&lt; "Person::~Person(), name_ = " &lt;&lt; name_ &lt;&lt; std::endl;
    }

    /**
     * @brief コピー代入演算子
     * @param rhs コピー元のPersonオブジェクト
     * @return Person&amp; このオブジェクトへの参照
     */
    Person&amp; operator=(const Person&amp; rhs) {
        name_ = rhs.name_;
        phone_ = rhs.phone_;
        std::cout &lt;&lt; "copy operator=, name_ = " &lt;&lt; name_ &lt;&lt; std::endl;

        return *this;
    }

    /**
     * @brief ムーブ代入演算子
     * @param rhs ムーブ元のPersonオブジェクト
     * @return Person&amp; このオブジェクトへの参照
     */
    Person&amp; operator=(Person&amp;&amp; rhs) noexcept {
        if (this != &amp;rhs) {
            name_ = std::move(rhs.name_);
            phone_ = std::move(rhs.phone_);
            std::cout &lt;&lt; "move operator=, name_ = " &lt;&lt; name_ &lt;&lt; std::endl;
        }
        return *this;
    }
    /**
     * @brief 名前を参照で取得
     * @return const std::string&amp; 名前の参照
     */
    const std::string&amp; getName() const
    {
        return name_;
    }
    /**
     * @brief 電話番号を参照で取得
     * @return const std::string&amp; 電話番号の参照
     */
    const std::string&amp; getPhone() const
    {
        return phone_;
    }
};

// グローバルな演算子オーバーロード */
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Person&amp; rhs)
{
    return (os &lt;&lt; '(' &lt;&lt; rhs.getName() &lt;&lt; ',' &lt;&lt; rhs.getPhone() &lt;&lt; ')');
}

// Person をコンソール出力
void PrintPerson(const Person&amp; person)
{
    std::cout &lt;&lt; person &lt;&lt; std::endl;
}

int main()
{
    const size_t    size_n = 4;
    std::unique_ptr&lt;Person[]&gt; persons = std::make_unique&lt;Person[]&gt;(size_n);

    auto zoo = Person("Zoo", "080-****-9999");

    persons[0] = zoo;
    persons[1] = Person("foo", "090-****-0123");
    persons[2] = Person("bar", "090-****-5555");
    persons[3] = Person("baz", "090-****-6666");


    for (size_t i = 0; i &lt; size_n; ++i) {
        PrintPerson(persons[i]);
    }

    return EXIT_SUCCESS;
}</pre>
      <p>&nbsp;</p>
      
      <p>ビルド例：</p>
      <pre class="prettyprint" style="width:800px">
$ g++ -Wall -Wextra -Wpedantic -g make_unique_04.cpp -o make_unique_04.out</pre>

      <p>&nbsp;</p>
    
      <p>実行結果：</p>
      <pre class="prettyprint" style="width:800px">
$ ./make_unique_04.out 
Person::Person(), name_ = 
Person::Person(), name_ = 
Person::Person(), name_ = 
Person::Person(), name_ = 
Person::Person(), name_ = Zoo
copy operator=, name_ = Zoo
Person::Person(), name_ = foo
move operator=, name_ = foo
Person::~Person(), name_ = 
Person::Person(), name_ = bar
move operator=, name_ = bar
Person::~Person(), name_ = 
Person::Person(), name_ = baz
move operator=, name_ = baz
Person::~Person(), name_ = 
(Zoo,080-****-9999)
(foo,090-****-0123)
(bar,090-****-5555)
(baz,090-****-6666)
Person::~Person(), name_ = Zoo
Person::~Person(), name_ = baz
Person::~Person(), name_ = bar
Person::~Person(), name_ = foo
Person::~Person(), name_ = Zoo
$</pre>
      <p>&nbsp;</p>
      <p>無駄なコンストラクタ、デストラクタ、の発生が気になりますが、この動作で正しいです。</p>
      <p>&nbsp;</p>
      
    </section>
    
    <p>&nbsp;</p>

    <section>
      <h3><a name="7-2._2次元配列">7-2. 2次元配列</a></h3>
      <p>2次元配列を扱う例を記載します。</p>
      <p>&nbsp;</p>
      <p>[ソースコード： "make_unique_05.cpp"]</p>
    
    <pre class="prettyprint linenums lang-cpp" style="width:800px">
/**
 * @brief std::unique_ptr と std::make_unique を使った2次元配列のサンプル
 *
 * このサンプルでは、std::unique_ptr を使って動的に2次元配列を作成し、
 * 各要素に値を代入して表示します。
 */

#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    const size_t rows = 3;
    const size_t cols = 4;

    // 行ごとに unique_ptr&lt;int[]&gt; を持つ unique_ptr の配列を作成
    auto matrix = std::make_unique&lt;std::unique_ptr&lt;int[]&gt;[]&gt;(rows);

    for (size_t i = 0; i &lt; rows; ++i) {
        matrix[i] = std::make_unique&lt;int[]&gt;(cols);
    }

    // 値の代入と表示
    for (size_t i = 0; i &lt; rows; ++i) {
        for (size_t j = 0; j &lt; cols; ++j) {
            matrix[i][j] = static_cast&lt;int&gt;(i * cols + j);
            std::cout &lt;&lt; matrix[i][j] &lt;&lt; " ";
        }
        std::cout &lt;&lt; "\n";
    }

    return 0;
}</pre>
      <p>&nbsp;</p>
      <p>ビルド例：</p>
      <pre class="prettyprint" style="width:800px">$ g++ -std=c++23 -O2 -Wall -Wextra -Wpedantic make_unique_05.cpp -o make_unique_05.out
$ </pre>
      <p>&nbsp;</p>
      <p>実行結果：</p>
      <pre class="prettyprint" style="width:800px">
$ ./make_unique_05.out 
0 1 2 3 
4 5 6 7 
8 9 10 11 
$ </pre>
      <p>&nbsp;</p>
    </section>
    
    <p>&nbsp;</p>
    
    <section>
      <h3><a name="7-3._3次元配列">7-3. 3次元配列</a></h3>
      <p>3次元配列を扱う例を記載します。</p>
      
      <p>[ソースコード： "make_unique_06.cpp"]</p>
      <pre class="prettyprint linenums lang-cpp" style="width:800px">
/**
 * @brief std::unique_ptr と std::make_unique を使った3次元配列のサンプル
 *
 * このサンプルでは、std::unique_ptr を使って動的に3次元配列を作成し、
 * 各要素に値を代入して表示します。
 */

#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    const size_t x = 2;
    const size_t y = 3;
    const size_t z = 4;

    // 3次元配列: unique_ptr&lt;unique_ptr&lt;unique_ptr&lt;int[]&gt;[]&gt;[]&gt;
    auto array3D = std::make_unique&lt;std::unique_ptr&lt;std::unique_ptr&lt;int[]&gt;[]&gt;[]&gt;(x);

    for (size_t i = 0; i &lt; x; ++i) {
        array3D[i] = std::make_unique&lt;std::unique_ptr&lt;int[]&gt;[]&gt;(y);
        for (size_t j = 0; j &lt; y; ++j) {
            array3D[i][j] = std::make_unique&lt;int[]&gt;(z);
        }
    }

    // 値の代入と表示
    for (size_t i = 0; i &lt; x; ++i) {
        for (size_t j = 0; j &lt; y; ++j) {
            for (size_t k = 0; k &lt; z; ++k) {
                array3D[i][j][k] = static_cast&lt;int&gt;(i * 100 + j * 10 + k);
                std::cout &lt;&lt; array3D[i][j][k] &lt;&lt; " ";
            }
            std::cout &lt;&lt; "\n";
        }
        std::cout &lt;&lt; "---\n";
    }

    return 0;
}</pre>
      <p>&nbsp;</p>
      <p>ビルド例：</p>
      <pre class="prettyprint" style="width:800px">$ g++ -std=c++23 -O2 -Wall -Wextra -Wpedantic make_unique_06.cpp -o make_unique_06.out
$ </pre>
      <p>&nbsp;</p>
      
      <p>実行例：</p>
      <pre class="prettyprint" style="width:800px">
$ ./make_unique_06.out 
0 1 2 3 
10 11 12 13 
20 21 22 23 
---
100 101 102 103 
110 111 112 113 
120 121 122 123 
---
$ </pre>
      <p>&nbsp;</p>
    </section>

    <p>&nbsp;</p>
  </section>

  <p>&nbsp;</p>

  <section>
    <h2><a name="ライセンス">ライセンス</a></h2>
    <p>本ページの情報は、特記無い限り下記 MIT ライセンスで提供されます。</p>
    <table class="border-collapse" style="width: 600px; background-color: #F0F0F0; word-break: break-word;">
      <tr>
        <td>
The MIT License (MIT)<br><br>

Copyright © 2014 Kinoshita Hidetoshi<br><br>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:<br><br>

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.<br><br>

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
        </td>
      </tr>
    </table>
    <p>&nbsp;</p>
  </section>

  <p>&nbsp;</p>

  <section>
    <h2><a name="参考">参考</a></h2>
    <ul>
      <li> <a href="http://ja.cppreference.com/w/cpp/memory/unique_ptr" target="_blank">
        http://ja.cppreference.com/w/cpp/memory/unique_ptr</a></li>
    </ul>
  </section>

  <p>&nbsp;</p>

  <hr>

  <p>&nbsp;</p>

  <section>
    <h2 style="margin-bottom:5px">変更履歴</h2>
    <table>
      <tr>
        <td class="td_history_date">2025-11-29</td>
        <td class="td_history_separator">-</td>
        <td class="td_history">"<a href="#2._関数の引数に使う">2._関数の引数に使う</a>" を追加</td>
      </tr>
      <tr>
        <td class="td_history_date">2025-11-22</td>
        <td class="td_history_separator">-</td>
        <td class="td_history">"<a href="#7._make_unique_配列版">7._make_unique_配列版</a>" 
        を追加</td>
      </tr>
      <tr>
        <td class="td_history_date">2025-11-10</td>
        <td class="td_history_separator">-</td>
        <td class="td_history">"<a href="#1._unique_ptr_を使ってみる">1._unique_ptr_を使ってみる</a>", "<a href="#6._make_unique">6._make_unique</a>" を更新</td>
      </tr>
      <tr>
        <td class="td_history_date">2022-07-13</td>
        <td class="td_history_separator">-</td>
        <td class="td_history">ページデザイン更新</td>
      </tr>
      <tr>
        <td class="td_history_date">2019-11-02</td>
        <td class="td_history_separator">-</td>
        <td class="td_history">「6. make_unique 配列版」を追加<br></td>
      </tr>
      <tr>
        <td class="td_history_date">2019-10-26</td>
        <td class="td_history_separator">-</td>
        <td class="td_history">「5. make_unique」を追加</td>
      </tr>
      <tr>
        <td class="td_history_date">2014-03-09</td>
        <td class="td_history_separator">-</td>
        <td class="td_history">新規作成 </td>
      </tr>
    </table>
  </section>

  <p>&nbsp;</p>

  <section>
    <p><a href="../../index.html" target="_parent">Programming Items トップページ</a></p>
    <p><a href="../../privacy_policy.html">プライバシーポリシー</a></p>
  </section>

  <p>&nbsp;</p>

  <footer>
    <p><small>Copyright © 2014 Kinoshita Hidetoshi (木下英俊)</small></p>
  </footer>

  <p>&nbsp;</p>
</body>
</html>
