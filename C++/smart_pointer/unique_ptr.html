<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="木下英俊">
  <meta name="description" content="木下英俊が自身のためにプログラムメモを残すことを目的に作成したページです。">
  <meta name="keywords" content="">
  <!-- キャッシュ無効化 -->
  <meta http-equiv="Cache-Control" content="no-cache">
  
  <!-- タイトル -->
  <title>std::unique_ptr | Programming Items</title>

  <!-- ファビコン -->
  <link rel="shortcut icon" href="../../favicon.ico">
  
  <!-- CSS -->
  <link href="https://unpkg.com/ress/dist/ress.min.css" rel="stylesheet">
	<link rel="stylesheet" href="../../design.css" type="text/css">
  
	<!-- Start for 'google-code-prettify' -->
  <link href="../../prettify/styles/desert.css" rel="stylesheet" type="text/css">
	<script src="../../prettify/prettify.js" type="text/javascript"></script>
	<!-- End for 'google-code-prettify' -->	

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-V2DZQK54C2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'G-V2DZQK54C2');
  </script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  
  <style type="text/css">
  .auto-style1 {
    background-color: #505000;
  }
  .auto-style2 {
    text-decoration: underline;
  }
  </style>
</head>

<body onload="prettyPrint();">

<h1>std::unique_ptr (c++11)</h1>
<p><strong><em>std::unique_ptr</em></strong> です。<span class="t-lines"><span><span class="t-mark"><strong><em>auto_ptr</em></strong> 
が deprecated（廃止予定）になりましたので、今後は <a href="shared_ptr.html">shared_ptr</a>, <strong>
<em>unique_ptr</em></strong> 
がスマートポインタの主流になっていくことでしょう。<br><strong><em>auto_ptr</em></strong> の後継という意味では  
<strong><em>unique_ptr</em></strong> の方がより近いかもしれません。</span></span></span></p>
<p>unique_ptr は下記２つの形式をサポートします。</p>
<ol>
	<li><span class="t-mark">template&lt;class T, class Deleter = 
	std::default_delete&lt;T&gt;&gt; class unique_ptr;</span></li>
	<li><span class="t-mark">template &lt;class T, class Deleter&gt; class 
	unique_ptr&lt;T[], Deleter&gt;;<br>⇨ 配列 T[] をサポートします。</span></li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="mokuji">
  <nav>
  <h2>目次</h2>
  <p><a href="#1._unique_ptr_を使ってみる">1. unique_ptr を使ってみる</a></p>
  <p><a href="#2. unique_ptr で動的配列を使う">2. unique_ptr で動的配列を使う</a></p>
  <p><a href="#3._malloc,_free_を_unique_ptr_に置き換える">3. malloc, free を unique_ptr に置き換える</a></p>
  <p><a href="#4. fopen, fclose を unique_ptr に置き換える">4. fopen, fclose を unique_ptr に置き換える</a></p>
  <p><a href="#5._make_unique">5. make_unique</a></p>
  <p><a href="#6._make_unique_配列版">6. make_unique 配列版</a></p>
  <p>&nbsp;</p>
  <p><a href="#ライセンス">ライセンス</a></p>
  <p><a href="#参考">参考</a></p>
  </nav>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>

  <section>
    <h2><a name="1._unique_ptr_を使ってみる">1. unique_ptr を使ってみる</a></h2>
    <p>まずは <strong><em>unique_ptr</em></strong> を使ってみます。<strong><em>shared_ptr</em></strong> 
    とほとんど同じ感じで使用できますが、コピーはできません。moveを使って管理者の譲渡と明示的に行う必要があります。</p>
    <p>&nbsp;</p>

  	<h4>[環境]</h4>
  	<table>
    	<tbody>
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>コンパイラ :</td>
    	      <td>g++ (Ubuntu 13.3.0-6ubuntu2~24.04), </td>
    	      <td>13.3.0</td>
    	  </tr>
    		
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>OS :</td>
    	    <td>Ubuntu 24.04 (WSL)</td>
    	    <td>&nbsp;</td>
    	  </tr>
    	  
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    	</tbody>
  	</table>

    <p>&nbsp;</p>
    <p>[ソースコード： "unique_ptr.cpp"]</p>
    
    <pre class="prettyprint linenums lang-cpp" style="width:800px">
#include &lt;iostream&gt;     // cout, endl
#include &lt;string&gt;       // string
#include &lt;memory&gt;       // unique_ptr
#include &lt;cstdlib&gt;      // EXIT_SUCCESS

class Person {
private:
    std::string name_;
    std::string phone_;

public:
    /**
     * @brief デフォルトコンストラクタ
     *        空の名前と電話番号で委譲コンストラクタを呼ぶ
     */
    Person()
        : Person("", "")                // 委譲コンストラクタ
    {
    }

    /**
     * @brief コピーコンストラクタ
     * @param rhs コピー元
     */
    Person(const Person&amp; rhs)
        : Person(rhs.name_, rhs.phone_)
    {
    }

    /**
     * @brief 値を指定するコンストラクタ
     * @param name 氏名
     * @param phone 電話番号
     */
    Person(std::string name, std::string phone)
        : name_(std::move(name)), phone_(std::move(phone))
    {
        std::cout &lt;&lt; "Person::Person()" &lt;&lt; std::endl;
    }

    /**
     * @brief デストラクタ
     */
    virtual ~Person()
    {
        std::cout &lt;&lt; "Person::~Person()" &lt;&lt; std::endl;
    }

    /**
     * @brief 名前を取得する
     * @return 名前への参照
     */
    const std::string&amp; getName() const
    {
        return name_;
    }

    /**
     * @brief 電話番号を取得する
     * @return 電話番号への参照
     */
    const std::string&amp; getPhone() const
    {
        return phone_;
    }
};


// Person を出力する演算子オーバーロード
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Person&amp; p)
{
    return (os &lt;&lt; '(' &lt;&lt; p.getName() &lt;&lt; ',' &lt;&lt; p.getPhone() &lt;&lt; ')');
}

/**
 * @brief Person をコンソール出力する（null 安全）
 * @param person 出力対象の unique_ptr
 */
void coutPerson(const std::unique_ptr&lt;Person&gt;&amp; person)
{
    if (person) {
        std::cout &lt;&lt; *person &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "(null)" &lt;&lt; std::endl;
    }
}

/**
 * @brief unique_ptr が指す Person を差し替える（所有権は引数で渡された参照側に残る）
 * @param person 差し替え対象の unique_ptr への参照
 */
void replacePerson(std::unique_ptr&lt;Person&gt;&amp; person)
{
    person = std::make_unique&lt;Person&gt;("bar_2", "090-****-????");
}

int main()
{
    // unique_ptr 生成
    std::unique_ptr&lt;Person&gt; foo = std::make_unique&lt;Person&gt;("foo", "090-****-0123");
    std::unique_ptr&lt;Person&gt; bar = std::make_unique&lt;Person&gt;("bar", "090-****-5555");
    std::unique_ptr&lt;Person&gt; hoge;

    // コンソール出力
    coutPerson(foo);        // (foo,090-****-0123)
    coutPerson(bar);        // (bar,090-****-5555)
    coutPerson(hoge);       // (null)

    // Person 差し替え
    replacePerson(bar);
    coutPerson(bar);        // (bar_2,090-****-????)

    // 所有権の移動
    hoge = std::move(foo);
    // hoge = foo;          // これはコンパイルエラーになる
    coutPerson(foo);        // (null)
    coutPerson(hoge);       // (foo,090-****-0123)

    return EXIT_SUCCESS;
}</pre>
    <p>&nbsp;</p>
    
    <p>ビルド(例)：</p>
    <pre class="prettyprint" style="width:800px">
$ g++ -Wall -g make_unique.cpp -o make_unique.out</pre>

    <p>&nbsp;</p>
    
    <p>実行結果：</p>
    <pre class="prettyprint" style="width:800px">
$ ./make_unique.out 
Person::Person()
Person::Person()
(foo,090-****-0123)
(bar,090-****-5555)
(null)
Person::Person()
Person::~Person()
(bar_2,090-****-????)
(null)
(foo,090-****-0123)
Person::~Person()
Person::~Person()
$ </pre>
    <p>&nbsp;</p>
    <p>3箇所でクラス Person のデストラクタが実行されている（"Person::~Person()" 
    の部分）ことから、unique_ptr が期待通りに解放処理を行っていることがわかります。</p>
    <p>&nbsp;</p>

</section>


<p>&nbsp;</p>
<h2><a name="2. unique_ptr で動的配列を使う">2. unique_ptr で動的配列を使う</a></h2>
<p><strong><em>unique_ptr</em></strong> で動的配列を使用する例です。<br>T[]の特殊化が組み込まれており、[]演算子も実装されています。直観的で気持ちよく使えます。<br>
ただし範囲外アクセスに対するチェック機構はありません。配列を使用したい場合、まずはコンテナの使用を検討するべきです。時々実行速度を問題にコンテナの使用を止めている場合がありますが、C++11で採用された 
std::array を使用すれば処理速度の問題もありません。</p>

<pre class="prettyprint linenums lang-cpp" style="width:800px">
<code>#include &lt;iostream&gt;         // cout, endl, EXIT_SUCCESS
#include &lt;string&gt;           // string
#include &lt;memory&gt;           // unique_ptr

using namespace std;

int main(int argc, char* argv[])
{
    // std::unique_ptr の例
    // default_delete の特殊化宣言は不要。delete[]が実行される。
    // []演算子もある。
    size_t  n = 10;
    std::<span class="auto-style1">unique_ptr</span>&lt;int[]&gt; data(new int[n]);

    cout &lt;&lt; "std::unique_ptr&lt;int&gt; : ";
    for (size_t i = 0; i &lt; n; ++i){
        data[i] = i;
    }
    for (size_t i = 0; i &lt; n; ++i){
        cout &lt;&lt; data[i] &lt;&lt; <span class="string">" "</span>;
    }
    cout &lt;&lt; endl;

    return EXIT_SUCCESS;
}</code></pre>

<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="3._malloc,_free_を_unique_ptr_に置き換える">3. malloc, free を unique_ptr に置き換える</a></h2>

<p>c 言語で規定されている malloc, calloc でメモリを動的に取得した場合、解放に使用する関数は delete や delete[] ではなく 
free を使用します。デアロケータを指定することで unique_ptr のメモリ解放を free で行えるようにします。</p>

<pre class="prettyprint linenums lang-cpp">
#include &lt;iostream&gt;     // cout, EXIT_SUCCESS
#include &lt;memory&gt;       // shared_ptr, unique_ptr
#include &lt;cstdlib&gt;      // malloc, free

using namespace std;

int main()
{
    const size_t    n = 256;

    // unique_ptr&lt;int[]&gt;
    std::<span class="auto-style1">unique_ptr</span>&lt;int[], decltype(&amp;free)&gt; memory(static_cast&lt;int*&gt; (malloc(n*sizeof(int))), std::free);    // &quot;decltype(&amp;free)&quot; は &quot;void(*)(void*)&quot; となるみたい
    // std::<span class="auto-style1">unique_ptr</span>&lt;int[], void(*)(void*)&gt; memory(static_cast&lt;int*&gt; (malloc(n*sizeof(int))), std::free);
    if (memory.get()==nullptr){
        // malloc失敗
    }
    else{
        // malloc成功
        for (size_t i = 0; i &lt; n; ++i){
            memory[i] = (int)i;
        }
        for (size_t i = 0; i &lt; n; ++i){
            cout &lt;&lt; memory[i] &lt;&lt; ", ";
        }
        cout &lt;&lt; endl;
    }

    return EXIT_SUCCESS;
}</pre>

<p>&nbsp;</p>
<h2><a name="4. fopen, fclose を unique_ptr に置き換える">4. fopen, fclose を unique_ptr 
に置き換える</a></h2>
<p>これは実装例をいくつか書いてみます。しっくりくるやつを使ってみてください。</p>
<h3>4-1. シンプルな実装例</h3>
<p>シンプルにやるとこんな感じでしょうか。</p>

<pre class="prettyprint linenums lang-cpp" style="width:800px">
#include &lt;stdio.h&gt;  <span class="comment">// fopen, fclose</span>
#include &lt;stdlib.h&gt;
#include &lt;memory&gt;   <span class="comment">// unique_ptr</span>

#pragma warning(disable : 4996) <span class="comment">// fopen, fclose の使用がエラーになるため</span>

void custom_fclose(FILE* fp){
    if (fp != nullptr){
        fclose(fp);
    }
}

int main(int argc, char* argv[])
{
<span class="auto-style1">    std::unique_ptr&lt;FILE, decltype(&amp;custom_fclose)&gt;   fp(fopen("fopen_test.txt", "w"), custom_fclose);</span>
<span class="auto-style1">    // std::unique_ptr&lt;FILE, void(*)(FILE*)&gt;   fp(fopen("fopen_test.txt", "w"), custom_fclose);</span>

    if (fp.get() != nullptr){
        // fopen成功
        fprintf(fp.get(), "test\n");
    }

    return EXIT_SUCCESS;
    // ここで custom_fclose が自動実行されます
}
</pre>

<h3>&nbsp;</h3>
<h3>4-2. Lambda式 による実装例</h3>
<p>Lambda式 で記載するとこんな感じでしょうか。</p>

<pre class="prettyprint linenums lang-cpp" style="width:800px">
#include &lt;stdio.h&gt;          // FILE, fopen, fclose
#include &lt;stdlib.h&gt;
#include &lt;memory&gt;           // unique_ptr

#pragma warning(disable : 4996)

int main(int argc, char* argv[])
{
<span class="auto-style1">    std::unique_ptr&lt;FILE, void(*)(FILE*)&gt;   fp(fopen("fopen_test.txt", "w"), [&amp;](FILE* fp){</span>
<span class="auto-style1">        if (fp != nullptr){</span>
<span class="auto-style1">            fclose(fp);</span>
<span class="auto-style1">        }</span>
<span class="auto-style1">    });</span>

    // 一応ファイルオープンの成功/失敗を確認してからファイルを使用
    if (fp.get() != nullptr){
        // fopen成功
        fprintf(fp.get(), "test\n");
    }

    return EXIT_SUCCESS;
    // ここで custom_fclose が自動実行されます
}</pre>

<h3>&nbsp;</h3>
<h3>4-3. ファクトリーパターン による実装例</h3>
<p>ファクトリーパターン的に unique_ptr を返す関数を作成するならばこんな感じでしょうか。</p>

<pre class="prettyprint linenums">
<code>#include &lt;cstdio&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // fopen, fclose
#include &lt;iostream&gt;&nbsp;&nbsp;&nbsp;&nbsp; // cout, EXIT_SUCCESS
#include &lt;memory&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // unique_ptr

using namespace std;

#pragma warning(disable : 4996)

std::<span class="auto-style1">unique_ptr</span>&lt;std::FILE, void(*)(FILE*)&gt; make_file(const char * filename, const char * flags)
{
&nbsp;&nbsp;&nbsp; // fclose に NULL を渡して実行してはいけない。
&nbsp;&nbsp;&nbsp; // このため下記のような分岐処理が必要となる。
&nbsp;&nbsp;&nbsp; std::FILE * const fp = std::fopen(filename, flags);
&nbsp;&nbsp;&nbsp; <span class="auto-style2">return fp ? std::<span class="auto-style1">unique</span></span>_ptr<span class="auto-style2">&lt;std::FILE<font face="Meiryo UI"><code>, void(*)(FILE*)</code></font>&gt;(fp, std::fclose) : std::<span class="auto-style1">unique_ptr</span>&lt;std::FILE<font face="Meiryo UI"><code>, void(*)(FILE*)</code></font>&gt;();</span>
}

int main()
{
&nbsp;&nbsp;&nbsp; auto fp = make_file("hello.txt", "wb");

&nbsp;&nbsp;&nbsp; // fp.get() をチェック
&nbsp;&nbsp;&nbsp; // fopen に失敗していたら fp.get() は NULL
&nbsp;&nbsp;&nbsp; if (fp.get()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(fp.get(), "Hello world.");
&nbsp;&nbsp;&nbsp; }
}</code></pre>

<p>私的には Lambda式 を使った2番目のやつが一番シンプルで好きかな。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>


  <section>
    <h2><a name="5._make_unique">5. make_unique</a></h2>
    
    <p>c++14 で <strong>make_unique</strong> が追加されました。Visual Studio は 2013 から対応しているようです。<br>unique_ptr 
    を使用する場合、いろいろな理由から <strong>make_unique</strong> を使用することが推奨みたいです。</p>
    <p>&nbsp;</p>

  	<h4>[環境]</h4>
  	<table>
    	<tbody>
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>コンパイラ :</td>
    	      <td>g++ (Ubuntu 13.3.0-6ubuntu2~24.04), </td>
    	      <td>13.3.0</td>
    	  </tr>
    		
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>OS :</td>
    	    <td>Ubuntu 24.04 (WSL)</td>
    	    <td>&nbsp;</td>
    	  </tr>
    	  
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    	</tbody>
  	</table>

    <p>&nbsp;</p>
    
    <p>[ソースコード： "unique_ptr.cpp"]</p>
    
    <pre class="prettyprint linenums lang-cpp" style="width:800px">
#include &lt;iostream&gt;     // cout, endl
#include &lt;string&gt;       // string
#include &lt;memory&gt;       // unique_ptr
#include &lt;cstdlib&gt;      // EXIT_SUCCESS

class Person {
private:
    std::string name_;
    std::string phone_;

public:
    /**
     * @brief デフォルトコンストラクタ
     *        空の名前と電話番号で委譲コンストラクタを呼ぶ
     */
    Person()
        : Person("", "")                // 委譲コンストラクタ
    {
    }

    /**
     * @brief コピーコンストラクタ
     * @param rhs コピー元
     */
    Person(const Person&amp; rhs)
        : Person(rhs.name_, rhs.phone_)
    {
    }

    /**
     * @brief 値を指定するコンストラクタ
     * @param name 氏名
     * @param phone 電話番号
     */
    Person(std::string name, std::string phone)
        : name_(std::move(name)), phone_(std::move(phone))
    {
        std::cout &lt;&lt; "Person::Person()" &lt;&lt; std::endl;
    }

    /**
     * @brief デストラクタ
     */
    virtual ~Person()
    {
        std::cout &lt;&lt; "Person::~Person()" &lt;&lt; std::endl;
    }

    /**
     * @brief 名前を取得する
     * @return 名前への参照
     */
    const std::string&amp; getName() const
    {
        return name_;
    }

    /**
     * @brief 電話番号を取得する
     * @return 電話番号への参照
     */
    const std::string&amp; getPhone() const
    {
        return phone_;
    }
};


// Person を出力する演算子オーバーロード
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Person&amp; p)
{
    return (os &lt;&lt; '(' &lt;&lt; p.getName() &lt;&lt; ',' &lt;&lt; p.getPhone() &lt;&lt; ')');
}

/**
 * @brief Person をコンソール出力する（null 安全）
 * @param person 出力対象の unique_ptr
 */
void coutPerson(const std::unique_ptr&lt;Person&gt;&amp; person)
{
    if (person) {
        std::cout &lt;&lt; *person &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "(null)" &lt;&lt; std::endl;
    }
}

/**
 * @brief unique_ptr が指す Person を差し替える（所有権は引数で渡された参照側に残る）
 * @param person 差し替え対象の unique_ptr への参照
 */
void replacePerson(std::unique_ptr&lt;Person&gt;&amp; person)
{
    person = std::make_unique&lt;Person&gt;("bar_2", "090-****-????");
}

int main()
{
    // unique_ptr 生成
    std::unique_ptr&lt;Person&gt; foo = std::make_unique&lt;Person&gt;("foo", "090-****-0123");
    std::unique_ptr&lt;Person&gt; bar = std::make_unique&lt;Person&gt;("bar", "090-****-5555");
    std::unique_ptr&lt;Person&gt; hoge;

    // コンソール出力
    coutPerson(foo);        // (foo,090-****-0123)
    coutPerson(bar);        // (bar,090-****-5555)
    coutPerson(hoge);       // (null)

    // Person 差し替え
    replacePerson(bar);
    coutPerson(bar);        // (bar_2,090-****-????)

    // 所有権の移動
    hoge = std::move(foo);
    // hoge = foo;          // これはコンパイルエラーになる
    coutPerson(foo);        // (null)
    coutPerson(hoge);       // (foo,090-****-0123)

    return EXIT_SUCCESS;
}</pre>

    <p>&nbsp;</p>
    
    <p>ビルド(例)：</p>
    <pre class="prettyprint" style="width:800px">
$ g++ -Wall -g make_unique.cpp -o make_unique.out</pre>

    <p>&nbsp;</p>
    
    <p>実行結果：</p>
    <pre class="prettyprint" style="width:800px">
$ ./make_unique.out 
Person::Person()
Person::Person()
(foo,090-****-0123)
(bar,090-****-5555)
(null)
Person::Person()
Person::~Person()
(bar_2,090-****-????)
(null)
(foo,090-****-0123)
Person::~Person()
Person::~Person()
$ </pre>

    <p>&nbsp;</p>
    
  </section>
    
  <p>&nbsp;</p>

  <section>
  
    <h2><a name="6._make_unique_配列版">6. make_unique 配列版</a></h2>
    <p>c++14 で追加された <strong>make_unique</strong> は 配列型T に対応しています。Visual Studio は 2013 から対応しているようです。<br>
    make_share は本文記載時点では 配列型T に未対応です。 c++20 で対応予定、VS2019 ver.16.3.6 でも未対応です。<br>&nbsp;unique_ptr 
    を使用する場合、いろいろな理由から <strong>make_unique</strong> を使用することが推奨みたいです。</p>
    <p>では同様に「<a href="#1._unique_ptr_を使ってみる">1. unique_ptr を使ってみる</a>」で記載したコードを  
    <strong>make_unique</strong> を使って書き換えてみます。</p>
    <p>■評価環境</p>
    <ul>
      <li>コンパイラ： Visual Studio 2019,&nbsp; Ver. 16.3.6</li>
      <li>OS： Windows10,&nbsp; Ver. 1903</li>
    </ul>
    <p>■参考URL</p>
    <ul>
      <li>
      <a href="https://cpprefjp.github.io/reference/memory/make_unique.html" target="_blank">
      https://cpprefjp.github.io/reference/memory/make_unique.html</a></li>
    </ul>
    <p>&nbsp;</p>

    <pre class="prettyprint linenums lang-cpp" style="width:800px">
#include &lt;tchar.h&gt;      // _TCHAR, _tmain
#include &lt;iostream&gt;     // cout, endl
#include &lt;string&gt;       // string
#include &lt;memory&gt;       // unique_ptr

using namespace std;

// class Person
class Person {
private:
    string  name_;
    string  phone_;

public:
    Person()
        : Person(&quot;&quot;, &quot;&quot;)                // 委譲コンストラクタ、VS2013 OK、VS2012 NG
//      : name_(&quot;&quot;), phone_(&quot;&quot;)
    {
    }
    // コピーコンストラクタ
    Person(const Person&amp; rhs)           // コピーコンストラクタ
        : Person(rhs.name_, rhs.phone_) // 委譲コンストラクタ、VS2013 OK、VS2012 NG
//      : name_(rhs.name_), phone_(rhs.phone_)
    {
    }
    Person(string name, string phone)
        : name_(name), phone_(phone)
    {
        cout &lt;&lt; &quot;Person::Person(), name_ = &quot; &lt;&lt; name_ &lt;&lt; endl;
    }

    // デストラクタ
    virtual ~Person()
    {
        cout &lt;&lt; &quot;Person::~Person(), name_ = &quot; &lt;&lt; name_ &lt;&lt; endl;
    }

    Person&amp; operator=(const Person&amp; rhd) {
        name_ = rhd.name_;
        phone_ = rhd.phone_;
        cout &lt;&lt; &quot;operator=, name_ = &quot; &lt;&lt; name_ &lt;&lt; endl;

        return *this;
    }

    const std::string getName() const
    {
        return name_;
    }
    const std::string getPhone() const
    {
        return phone_;
    }
};

// グローバルな演算子オーバーロード */
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Person&amp; rhs)
{
    return (os &lt;&lt; &#39;(&#39; &lt;&lt; rhs.getName() &lt;&lt; &#39;,&#39; &lt;&lt; rhs.getPhone() &lt;&lt; &#39;)&#39;);
}

// Person をコンソール出力
void PrintPerson(Person&amp; person)
{
    cout &lt;&lt; person &lt;&lt; endl;
}

int _tmain(int argc, _TCHAR* argv[])
{
    const size_t    size_n = 3;
    unique_ptr&lt;Person[]&gt; persons = <span class="auto-style1">make_unique</span>&lt;Person[]&gt;(size_n);

    persons[0] = Person(&quot;foo&quot;, &quot;090-****-0123&quot;);
    persons[1] = Person(&quot;bar&quot;, &quot;090-****-5555&quot;);
    persons[2] = Person(&quot;baz&quot;, &quot;090-****-6666&quot;);

    for (int i = 0; i &lt; size_n; ++i) {
        PrintPerson(persons[i]);
    }

    return EXIT_SUCCESS;
}</pre>

    <p>&nbsp;</p>
    <p>&nbsp;</p>

    <p>[実行結果]</p>
    <p><img alt="" src="unique_ptr/imgD.jpg"></p>
    <p>無駄なコンストラクタ、デストラクタ、の発生が気になりますが、この動作で正しいです。</p>
    <p>&nbsp;</p>
  </section>

  <p>&nbsp;</p>

  <section>
    <h2><a name="ライセンス">ライセンス</a></h2>
    <p>本ページの情報は、特記無い限り下記 MIT ライセンスで提供されます。</p>
    <table class="border-collapse" style="width: 600px; background-color: #F0F0F0; word-break: break-word;">
      <tr>
        <td>
The MIT License (MIT)<br><br>

Copyright © 2014 Kinoshita Hidetoshi<br><br>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:<br><br>

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.<br><br>

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
        </td>
      </tr>
    </table>
    <p>&nbsp;</p>
  </section>

  <p>&nbsp;</p>

  <section>
    <h2><a name="参考">参考</a></h2>
    <ul>
      <li> <a href="http://ja.cppreference.com/w/cpp/memory/unique_ptr" target="_blank">
        http://ja.cppreference.com/w/cpp/memory/unique_ptr</a></li>
    </ul>
  </section>

  <p>&nbsp;</p>

  <hr>

  <p>&nbsp;</p>

  <section>
    <h2 style="margin-bottom:5px">変更履歴</h2>
    <table>
      <tr>
        <td class="td_history_date">2025-11-10</td>
        <td class="td_history_separator">-</td>
        <td class="td_history">"<a href="#1._unique_ptr_を使ってみる">1._unique_ptr_を使ってみる</a>", "<a href="#5._make_unique">5._make_unique</a>" を更新</td>
      </tr>
      <tr>
        <td class="td_history_date">2022-07-13</td>
        <td class="td_history_separator">-</td>
        <td class="td_history">ページデザイン更新</td>
      </tr>
      <tr>
        <td class="td_history_date">2019-11-02</td>
        <td class="td_history_separator">-</td>
        <td class="td_history">「6. make_unique 配列版」を追加<br></td>
      </tr>
      <tr>
        <td class="td_history_date">2019-10-26</td>
        <td class="td_history_separator">-</td>
        <td class="td_history">「5. make_unique」を追加</td>
      </tr>
      <tr>
        <td class="td_history_date">2014-03-09</td>
        <td class="td_history_separator">-</td>
        <td class="td_history">新規作成 </td>
      </tr>
    </table>
  </section>

  <p>&nbsp;</p>

  <section>
    <p><a href="../../index.html" target="_parent">Programming Items トップページ</a></p>
    <p><a href="../../privacy_policy.html">プライバシーポリシー</a></p>
  </section>

  <p>&nbsp;</p>

  <footer>
    <p><small>Copyright © 2014-2022 Kinoshita Hidetoshi (木下英俊)</small></p>
  </footer>

  <p>&nbsp;</p>
</body>
</html>
