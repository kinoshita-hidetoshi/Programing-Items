<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="kinoshita hidetoshi (木下 英俊)">
  <meta name="description" content="木下英俊が自身のためにプログラムメモを残すことを目的に作成したページです">
  <meta name="keywords" content="">
  <!-- キャッシュ無効化 -->
  <meta http-equiv="Cache-Control" content="no-cache">
	
  <!-- タイトル -->
  <title>Singleton パターン | Programming Items</title>
	
  <!-- ファビコン -->
  <link rel="shortcut icon" href="../../favicon.ico">
  
  <!-- CSS -->
  <link href="https://unpkg.com/ress/dist/ress.min.css" rel="stylesheet">
	<link rel="stylesheet" href="../../design.css" type="text/css">
  
	<!-- Start for 'google-code-prettify' -->
	<link href="../../prettify/styles/desert.css" rel="stylesheet" type="text/css">
	<script src="../../prettify/prettify.js" type="text/javascript"></script>
	<!-- End for 'google-code-prettify' -->	
	
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-V2DZQK54C2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'G-V2DZQK54C2');
  </script>
  <!-- Global site tag (gtag.js) - Google Analytics -->

</head>

<body onload="prettyPrint();">
	
  <h1>Singleton パターン | デザインパターン (c++)</h1>
  
  <p><strong>Singleton パターン</strong>（シングルトン・パターン）とは、オブジェクト指向のコンピュータプログラムにおける、デザインパターンの1つです。GoF&nbsp;(Gang 
  of Four; 4人のギャングたち) によって定義されました。Singleton パターンを使用することで、そのクラスのインスタンスが1つしか生成されないことを保証するデザインパターンです。</p>
  <p>&nbsp;</p>
  
  <div class="mokuji">
    <nav>
    	<h2>目次</h2>
    	<p><a href="#1._静的ローカル変数方式_（Meyers_シングルトン）">1. 静的ローカル変数方式 （Meyers シングルトン）</a></a></p>
      <p>2. 静的メンバ変数方式 </p>
      <p>3. ダブルチェックロッキング方式 </p>
      <p>4. テンプレートベースの汎用シングルトン </p>
    	<p>&nbsp;</p>
    	<p><a href="#ライセンス">ライセンス</a></p>
    	<p><a href="#参考">参考</a></p>
    </nav>
  </div>
  
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  
  <section>
  	<h2><a name="1._静的ローカル変数方式_（Meyers_シングルトン）">1. 静的ローカル変数方式 （Meyers シングルトン）</a></a></h2>
  	<h4>[概要]</h4>
  	<p> Singleton パターン、の最初のサンプルプログラムを作成してみます。</p>
    <p> このサンプルは、シンプルなシングルトン型の <span class="cpp-source">Logger</span> 
    を提供します。主な特徴は以下の通りです。</p>
    <ul>
      <li>Meyers シングルトン:<br><span class="cpp-source">Logger::getInstance()</span> 
      は関数内静的変数を用いた遅延初期化を行い、C++11 以降の言語仕様でスレッドセーフに初期化されます<br>⇨ 唯一のインスタンスを  
      <span class="cpp-source">Logger::getInstance()</span> メソッド内で宣言しています (<span class="cpp-source"><strong>static</strong> Logger instance;</span>)<br>
      この <span class="cpp-source"><strong>static</strong> Logger instance;</span> 
      の部分がポイント！C++11以降では、関数内のstatic変数は初期化がスレッドセーフに保証されているため、複雑なロック処理なしで安全に使えます</li>
      <li>&nbsp;スレッドセーフ: <br>内部で <span class="cpp-source">std::mutex</span> 
      を使って標準出力へのアクセスを直列化します</li>
      <li>破棄タイミングも自動管理（プログラム終了時）</li>
      <li>基本 API: &nbsp;
      <ul>
        <li><span class="cpp-source">static Logger&amp;  getInstance()</span> : 
        シングルトンインスタンスを取得します</li>
        <li><span class="cpp-source">void log(const std::string&amp; message)</span> 
        : スレッドセーフにメッセージを標準出力へ出力し、内部カウンタを増加します</li>
        <li><span class="cpp-source">std::size_t getCount() const</span> : 
        これまでに出力したメッセージ数を返します</li>
      </ul>
      </li>
    </ul>
    <p>&nbsp;</p>
  
    <div class="status_information">
      <div></div>
      <div>
        <p><strong>NOTE</strong></p>
        <p><strong>Meyers シングルトン</strong>とは、Scott Meyers 
        が提唱した「関数内静的変数を使ったシングルトン実装」のことです。簡潔に説明すると以下の通りです。</p>
        <ul>
          <li><strong>実装</strong>: シングルトンのインスタンスを返す関数内で static 変数を定義し、その参照を返す</li>
          <li><strong>特徴</strong>: 遅延初期化（最初の呼び出し時に初期化）され、C++11 以降は言語仕様で関数内 
          static の初期化がスレッドセーフになっているため追加の同期が不要</li>
          <li><strong>利点</strong>: 実装が非常にシンプルで安全（多重初期化やデータ競合の心配が少ない）、ヘッダや実装の分離が楽</li>
          <li><strong>注意点</strong>: 
          グローバル状態になるため設計上の影響を受ける（テストや依存注入が難しくなる）、引数付きコンストラクタが使えない、プログラム終了時の破棄順序に依存する問題が残る場合がある</li>
        </ul>
      </div>
    </div>

    <p>&nbsp;</p>
    <p>&nbsp;</p>
  	
  	<h4>[環境]</h4>
  	<table>
    	<tbody>
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>コンパイラ :</td>
    	      <td>g++</td>
    	      <td>13.3.0</td>
    	  </tr>
    		
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>OS :</td>
    	    <td>Ubuntu</td>
    	    <td>24.04.3 LTS</td>
    	  </tr>
    	  
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    	</tbody>
  	</table>
  	
  	<p> &nbsp;</p>
    
  	<h4>[コード]</h4>
    <div class="status_ok">
      <div></div>
      <div>
        <p><strong>POINT</strong></p>
        <ul>
          <li>&nbsp;唯一のインスタンスを getInstance メソッド内で宣言 <span class="cpp-source">
          <strong>static</strong> Logger instance;</span></li>
          <li>&nbsp;コンストラクタ、デストラクタを private とし、外部から new, delete されるのを防ぐ</li>
          <li>コピー/ムーブを削除してシングルトンを保証</li>
        </ul>
      </div>
    </div>

    <p> &nbsp;</p>
    <p> ["logger.h"]</p>
    
    <pre class="prettyprint linenums lang-cpp" style="width:1000px">
// logger.h
#pragma once

#include &lt;atomic&gt;           // for std::atomic
#include &lt;mutex&gt;            // for std::mutex
#include &lt;string&gt;           // for std::string

namespace singleton_example {

/**
 * @brief スレッドセーフなシングルトンとして実装されたロガークラスのヘッダ。
 *
 * Meyers シングルトンを用いて遅延初期化を行います。
 */
class Logger {
private:
    mutable std::mutex mutex_;
    std::atomic&lt;std::size_t&gt; counter_{0};

    Logger() = default;
    ~Logger() = default;

public:
    // コピー/ムーブを削除してシングルトンを保証
    Logger(const Logger&amp;) = delete;
    Logger&amp; operator=(const Logger&amp;) = delete;
    Logger(Logger&amp;&amp;) = delete;
    Logger&amp; operator=(Logger&amp;&amp;) = delete;

    /**
     * @brief シングルトン Logger のインスタンスを取得する。
     *
     * @return Logger&amp; シングルトンの Logger インスタンスへの参照。
     */
    static Logger&amp; getInstance();

    /**
     * @brief メッセージをログ出力する。
     *
     * @param message 出力するログメッセージ。
     */
    void log(const std::string&amp; message);

    /**
     * @brief これまでにログ出力したメッセージ数を取得する。
     *
     * @return std::size_t 出力済みメッセージの総数。
     */
    std::size_t getCount() const;
};

} // namespace singleton_example</pre>

    <p> &nbsp;</p>
    <p> ["logger.cpp"]</p>
    
    <pre class="prettyprint linenums lang-cpp" style="width:1000px">
// logger.cpp
#include "logger.h"

#include &lt;iostream&gt;

namespace singleton_example {

Logger&amp; Logger::getInstance()
{
    static Logger instance;
    return instance;
}

void Logger::log(const std::string&amp; message)
{
    std::lock_guard&lt;std::mutex&gt; lock(mutex_);
    ++counter_;
    std::cout &lt;&lt; "[" &lt;&lt; counter_ &lt;&lt; "] " &lt;&lt; message &lt;&lt; std::endl;
}

std::size_t Logger::getCount() const
{
    return counter_.load();
}

} // namespace singleton_example</pre>

    <p> &nbsp;</p>
    <p> ["singleton_pattern_01.cpp"]</p>
    
    <pre class="prettyprint linenums lang-cpp" style="width:1000px">
// singleton_pattern_01.cpp
// C++23 サンプル: スレッドセーフな Meyers スタイルのシングルトン（簡単な使用例）
// プロジェクト規約に従っています: 関数は camelCase、変数は snake_case、公開 API は Doxygen コメントを使用

#include &lt;iostream&gt;
#include &lt;thread&gt;       // for std::thread, std::this_thread::yield
#include &lt;vector&gt;       // for std::vector

#include "logger.h"

using singleton_example::Logger;

int main()
{
    // シングルトンへの同時アクセスを示すために複数スレッドを生成
    const int num_threads = 6;
    const int messages_per_thread = 5;

    std::vector&lt;std::thread&gt; threads;
    threads.reserve(num_threads);

    for (int t = 0; t &lt; num_threads; ++t) {
        threads.emplace_back([t, messages_per_thread]() {
            for (int i = 0; i &lt; messages_per_thread; ++i) {
                Logger::getInstance().log("thread " + std::to_string(t) + " message " + std::to_string(i));
                // 出力が混在する可能性を高めるために少し yield する
                std::this_thread::yield();
            }
        });
    }

    for (auto&amp; th : threads) {
        th.join();
    }

    std::cout &lt;&lt; "合計ログ数: " &lt;&lt; Logger::getInstance().getCount() &lt;&lt; std::endl;
    return 0;
}</pre>

    <p> &nbsp;</p>
    
    <p> ビルド方法：</p>
    <p> 上記3つのソースファイルを同じ場所に保存し、下記コマンドでビルドします。</p>
    <pre class="prettyprint lang-bsh" style="width:1000px">g++ -std=c++20 -Wall -Wextra -Wpedantic -pthread singleton_pattern_01.cpp logger.cpp -o singleton_pattern_01.out</pre>
    
    <p> &nbsp;</p>
    
    <p> 実行方法：</p>
    <pre class="prettyprint lang-sh" style="width:500px">./singleton_pattern_01.out</pre>
    
    <p> &nbsp;</p>
    
    <p> 実行結果：</p>
    <pre class="prettyprint lang-bsh" style="width:500px">
$ ./singleton_pattern_01.out 
[1] thread 0 message 0
[2] thread 0 message 1
[3] thread 1 message 0
[4] thread 1 message 1
[5] thread 1 message 2
[6] thread 1 message 3
[7] thread 0 message 2
[8] thread 0 message 3
[9] thread 3 message 0
[10] thread 4 message 0
[11] thread 4 message 1
[12] thread 4 message 2
[13] thread 4 message 3
[14] thread 4 message 4
[15] thread 0 message 4
[16] thread 2 message 0
[17] thread 2 message 1
[18] thread 2 message 2
[19] thread 2 message 3
[20] thread 2 message 4
[21] thread 3 message 1
[22] thread 3 message 2
[23] thread 3 message 3
[24] thread 3 message 4
[25] thread 1 message 4
[26] thread 5 message 0
[27] thread 5 message 1
[28] thread 5 message 2
[29] thread 5 message 3
[30] thread 5 message 4
合計ログ数: 30
$ </pre>

    <p> &nbsp;</p>
	
  </section>
  	
  <p> &nbsp;</p>
    
  <section>
    <h2> 2. 静的メンバ変数方式</h2>
  	<h4>[概要]</h4>
    <p>&nbsp;</p>
  
    <div class="status_information">
      <div></div>
      <div>
        <p><strong>NOTE</strong></p>
        <ul>
          <li>明示的に new で生成</li>
          <li>&nbsp;スレッドセーフではないので、ロックが必要</li>
          <li>破棄タイミングの制御が難しい</li>
        </ul>
      </div>
    </div>

    <p>&nbsp;</p>
  	<p> &nbsp;</p>
  	
  	<h4>[環境]</h4>
  	<table>
    	<tbody>
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>コンパイラ :</td>
    	      <td>g++</td>
    	      <td>13.3.0</td>
    	  </tr>
    		
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>OS :</td>
    	    <td>Ubuntu</td>
    	    <td>24.04.3 LTS</td>
    	  </tr>
    	  
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    	</tbody>
  	</table>
  	
	  <p> &nbsp;</p>
    <p> &nbsp;</p>
    <h4> [コード]</h4>
  	<p>[プログラムソース &quot;***.cpp&quot;]</p>
    <pre class="prettyprint linenums lang-cpp" style="width:1000px">
class Singleton {
private:
    static Singleton* instance;
    Singleton() {}
public:
    static Singleton* getInstance() {
        if (!instance) {
            instance = new Singleton();
        }
        return instance;
    }
};
Singleton* Singleton::instance = nullptr;</pre>

    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p> &nbsp;</p>
  </section>
	
  <p> &nbsp;</p>

  <section>
    <h2> 3. ダブルチェックロッキング方式</h2>
  	<h4>[概要]</h4>
    <p>&nbsp;</p>
  
    <div class="status_information">
      <div></div>
      <div>
        <p><strong>NOTE</strong></p>
        <ul>
          <li>マルチスレッド環境での安全性を確保</li>
          <li>&nbsp;実装が複雑で、C++11 以降でも注意が必要</li>
        </ul>
      </div>
    </div>

    <p>&nbsp;</p>
  	<p> &nbsp;</p>
  	
  	<h4>[環境]</h4>
  	<table>
    	<tbody>
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>コンパイラ :</td>
    	      <td>g++</td>
    	      <td>13.3.0</td>
    	  </tr>
    		
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>OS :</td>
    	    <td>Ubuntu</td>
    	    <td>24.04.3 LTS</td>
    	  </tr>
    	  
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    	</tbody>
  	</table>
  	
	  <p> &nbsp;</p>
    <p> &nbsp;</p>
    <h4> [コード]</h4>
    
  	<p>[プログラムソース &quot;***.cpp&quot;]</p>
    <pre class="prettyprint linenums lang-cpp" style="width:1000px">
std::mutex mtx;
Singleton* Singleton::instance = nullptr;

Singleton* Singleton::getInstance() {
    if (!instance) {
        std::lock_guard&lt;std::mutex&gt; lock(mtx);
        if (!instance) {
            instance = new Singleton();
        }
    }
    return instance;
}</pre>

    <p>&nbsp;</p>
  </section>
	
  <p> &nbsp;</p>

  <section>
    <h2> 4. テンプレートベースの汎用シングルトン</h2>
  	<h4>[概要]</h4>
    <p>&nbsp;</p>
  
    <div class="status_information">
      <div></div>
      <div>
        <p><strong>NOTE</strong></p>
        <ul>
          <li>汎用的に使える</li>
          <li>&nbsp;<span class="cpp-source">T</span> によって異なる型のシングルトンを生成可能。 </li>
        </ul>
      </div>
    </div>

    <p>&nbsp;</p>
  	<p> &nbsp;</p>
  	
  	<h4>[環境]</h4>
  	<table>
    	<tbody>
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>コンパイラ :</td>
    	      <td>g++</td>
    	      <td>13.3.0</td>
    	  </tr>
    		
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>OS :</td>
    	    <td>Ubuntu</td>
    	    <td>24.04.3 LTS</td>
    	  </tr>
    	  
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    	</tbody>
  	</table>
  	
	  <p> &nbsp;</p>
    <h4> [コード]</h4>
  	<p>[プログラムソース &quot;***.cpp&quot;]</p>
    <pre class="prettyprint linenums lang-cpp" style="width:1000px">
template &lt;typename T&gt;
class Singleton {
public:
    static T&amp; instance() {
        static T instance;
        return instance;
    }
};</pre>

    <p> &nbsp;</p>
  </section>
	
  <p> &nbsp;</p>

  <section>
    <h2><a id="ライセンス">ライセンス</a></h2>
    <p>本ページの情報は、特記無い限り下記 MIT ライセンスで提供されます。</p>
    <div class="license">
      The MIT License (MIT)<br><br>
      
      &nbsp; Copyright 2025 Kinoshita Hidetoshi<br><br>
      
      Permission is hereby granted, free of charge, to any person obtaining a copy
      of this software and associated documentation files (the "Software"), to deal
      in the Software without restriction, including without limitation the rights
      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      copies of the Software, and to permit persons to whom the Software is
      furnished to do so, subject to the following conditions:<br><br>
      
      The above copyright notice and this permission notice shall be included in all
      copies or substantial portions of the Software.<br><br>
      
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      SOFTWARE.
    </div>
    <p>&nbsp;</p>
  </section>
  
  <p> &nbsp;</p>
  
  <section>
  	<h2><a id="参考">参考</a></h2>
  	<ul>
  		<li>
        <a href="https://ja.wikipedia.org/wiki/デザインパターン_(ソフトウェア)" target="_blank">デザインパターン 
        (ソフトウェア) - Wikipedia</a></li>
        <li>
        <a href="https://ja.wikipedia.org/wiki/Singleton_パターン" target="_blank">
        Singleton パターン - Wikipedia</a></li>
  	</ul>
  </section>
  
  <p>&nbsp;</p>
  <hr>
  <p>&nbsp;</p>
  
  <section>
  	<h2 style="margin-bottom:5px">変更履歴</h2>
  	<table>
  	  <tr>
  	    <td class="td_history_date">2025-11-01</td>
  	    <td class="td_history_separator">-</td>
  	    <td class="td_history">新規作成 </td>
  	  </tr>
  	</table>
  </section>
  
  <p>&nbsp;</p>
  
  <section>
    <p><a href="../../index.html" target="_parent">Programming Items トップページ</a></p>
    <p><a href="../../privacy_policy.html">プライバシーポリシー</a></p>
  </section>
  
  <p>&nbsp;</p>
  
  <footer>
  	<p><small>&copy; 2025 Kinoshita Hidetoshi (木下英俊)</small></p>
  </footer>
  
</body>
</html>
