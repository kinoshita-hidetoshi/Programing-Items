<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="kinoshita hidetoshi (木下 英俊)">
  <meta name="description" content="木下英俊が自身のためにプログラムメモを残すことを目的に作成したページです">
  <meta name="keywords" content="">
  <!-- キャッシュ無効化 -->
  <meta http-equiv="Cache-Control" content="no-cache">
	
  <!-- タイトル -->
  <title>Singleton パターン | Programming Items</title>
	
  <!-- ファビコン -->
  <link rel="shortcut icon" href="../../favicon.ico">
  
  <!-- CSS -->
  <link href="https://unpkg.com/ress/dist/ress.min.css" rel="stylesheet">
	<link rel="stylesheet" href="../../design.css" type="text/css">
  
	<!-- Start for 'google-code-prettify' -->
	<link href="../../prettify/styles/desert.css" rel="stylesheet" type="text/css">
	<script src="../../prettify/prettify.js" type="text/javascript"></script>
	<!-- End for 'google-code-prettify' -->	
	
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-V2DZQK54C2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'G-V2DZQK54C2');
  </script>
  <!-- Global site tag (gtag.js) - Google Analytics -->

  <style type="text/css">
  .auto-style1 {
    background-color: #505000;
  }
  </style>

</head>

<body onload="prettyPrint();">
	
  <h1>Singleton パターン | デザインパターン (c++)</h1>
  
  <p><strong>Singleton パターン</strong>（シングルトン・パターン）とは、オブジェクト指向のコンピュータプログラムにおける、デザインパターンの1つです。GoF&nbsp;(Gang 
  of Four; 4人のギャングたち) によって定義されました。Singleton パターンを使用することで、そのクラスのインスタンスが1つしか生成されないことを保証するデザインパターンです。</p>
  <p>&nbsp;</p>
  
  <div class="mokuji">
    <nav>
    	<h2>目次</h2>
    	<p><a href="#1._静的ローカル変数方式_（Meyers_シングルトン）">1. 静的ローカル変数方式 （Meyers シングルトン）</a> </p>
      <p><a href="#2._静的メンバ変数方式">2. 静的メンバ変数方式 </a> </p>
      <p>3. ダブルチェックロッキング方式 </p>
      <p>4. テンプレートベースの汎用シングルトン </p>
    	<p>&nbsp;</p>
    	<p><a href="#ライセンス">ライセンス</a></p>
    	<p><a href="#参考">参考</a></p>
    </nav>
  </div>
  
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  
  <section>
  	<h2><a name="1._静的ローカル変数方式_（Meyers_シングルトン）">1. 静的ローカル変数方式 （Meyers シングルトン）</a></a></h2>
  	<h4>[概要]</h4>
  	<p> Singleton パターン、の最初のサンプルプログラムを作成してみます。</p>
    <p> 「Meyers シングルトン」と呼ばれるシンプルなシングルトン型の <span class="cpp-source">Logger</span> 
    を紹介します。</p>
    <p> 主な特徴は以下の通りです。</p>
    <ul>
      <li>Meyers シングルトン:<br><span class="cpp-source">Logger::getInstance()</span> 
      は関数内静的変数を用いた遅延初期化を行い、C++11 以降の言語仕様でスレッドセーフに初期化されます<br>⇨ 唯一のインスタンスを  
      <span class="cpp-source">Logger::getInstance()</span> メソッド内で宣言しています (<span class="cpp-source"><strong>static</strong> Logger instance;</span>)<br>
      この <span class="cpp-source"><strong>static</strong> Logger instance;</span> 
      の部分がポイント！C++11以降では、関数内のstatic変数は初期化がスレッドセーフに保証されているため、複雑なロック処理なしで安全に使えます</li>
      <li>&nbsp;スレッドセーフ: <br>内部で <span class="cpp-source">std::mutex</span> 
      を使って標準出力へのアクセスを直列化します</li>
      <li>破棄タイミングも自動管理（プログラム終了時）</li>
      <li>基本 API: &nbsp;
      <ul>
        <li><span class="cpp-source">static Logger&amp;  getInstance()</span> : 
        シングルトンインスタンスを取得します</li>
        <li><span class="cpp-source">void log(const std::string&amp; message)</span> 
        : スレッドセーフにメッセージを標準出力へ出力し、内部カウンタを増加します</li>
        <li><span class="cpp-source">std::size_t getCount() const</span> : 
        これまでに出力したメッセージ数を返します</li>
      </ul>
      </li>
    </ul>
    <p>&nbsp;</p>
  
    <div class="status_information">
      <div></div>
      <div>
        <p><strong>NOTE</strong></p>
        <p><strong>Meyers シングルトン</strong>とは、Scott Meyers 
        が提唱した「関数内静的変数を使ったシングルトン実装」のことです。簡潔に説明すると以下の通りです。</p>
        <ul>
          <li><strong>実装</strong>: シングルトンのインスタンスを返す関数内で static 変数を定義し、その参照を返す</li>
          <li><strong>特徴</strong>: 遅延初期化（最初の呼び出し時に初期化）され、C++11 以降は言語仕様で関数内 
          static の初期化がスレッドセーフになっているため追加の同期が不要</li>
          <li><strong>利点</strong>: 実装が非常にシンプルで安全（多重初期化やデータ競合の心配が少ない）、ヘッダや実装の分離が楽</li>
          <li><strong>注意点</strong>: 
          グローバル状態になるため設計上の影響を受ける（テストや依存注入が難しくなる）、引数付きコンストラクタが使えない、プログラム終了時の破棄順序に依存する問題が残る場合がある</li>
        </ul>
      </div>
    </div>

    <p>&nbsp;</p>
    <p>&nbsp;</p>
  	
  	<h4>[環境]</h4>
  	<table>
    	<tbody>
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>コンパイラ :</td>
    	      <td>g++</td>
    	      <td>13.3.0</td>
    	  </tr>
    		
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>OS :</td>
    	    <td>Ubuntu</td>
    	    <td>24.04.3 LTS</td>
    	  </tr>
    	  
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    	</tbody>
  	</table>
  	
  	<p> &nbsp;</p>
    
  	<h4>[コード]</h4>
    <div class="status_ok">
      <div></div>
      <div>
        <p><strong>POINT</strong></p>
        <ul>
          <li>&nbsp;唯一のインスタンスを getInstance メソッド内で宣言 <span class="cpp-source">
          <strong>static</strong> Logger instance;</span></li>
          <li>&nbsp;コンストラクタ、デストラクタを private とし、外部から new, delete されるのを防ぐ</li>
          <li>コピー/ムーブを削除してシングルトンを保証</li>
        </ul>
      </div>
    </div>

    <p> &nbsp;</p>
    <p> ["logger.h"]</p>
    
    <pre class="prettyprint linenums lang-cpp" style="width:1000px">
// logger.h
#pragma once

#include &lt;atomic&gt;           // for std::atomic
#include &lt;mutex&gt;            // for std::mutex
#include &lt;string&gt;           // for std::string

namespace singleton_example {

/**
 * @brief スレッドセーフなシングルトンとして実装されたロガークラスのヘッダ。
 *
 * Meyers シングルトンを用いて遅延初期化を行います。
 */
class Logger {
private:
    mutable std::mutex mutex_;
    std::atomic&lt;std::size_t&gt; counter_{0};

    Logger() = default;
    ~Logger() = default;

public:
    // コピー/ムーブを削除してシングルトンを保証
    Logger(const Logger&amp;) = delete;
    Logger&amp; operator=(const Logger&amp;) = delete;
    Logger(Logger&amp;&amp;) = delete;
    Logger&amp; operator=(Logger&amp;&amp;) = delete;

    /**
     * @brief シングルトン Logger のインスタンスを取得する。
     *
     * @return Logger&amp; シングルトンの Logger インスタンスへの参照。
     */
    static Logger&amp; getInstance();

    /**
     * @brief メッセージをログ出力する。
     *
     * @param message 出力するログメッセージ。
     */
    void log(const std::string&amp; message);

    /**
     * @brief これまでにログ出力したメッセージ数を取得する。
     *
     * @return std::size_t 出力済みメッセージの総数。
     */
    std::size_t getCount() const;
};

} // namespace singleton_example</pre>

    <p> &nbsp;</p>
    <p> ["logger.cpp"]</p>
    
    <pre class="prettyprint linenums lang-cpp" style="width:1000px">
// logger.cpp
#include "logger.h"

#include &lt;iostream&gt;

namespace singleton_example {

Logger&amp; Logger::getInstance()
{
    static Logger instance;
    return instance;
}

void Logger::log(const std::string&amp; message)
{
    std::lock_guard&lt;std::mutex&gt; lock(mutex_);
    ++counter_;
    std::cout &lt;&lt; "[" &lt;&lt; counter_ &lt;&lt; "] " &lt;&lt; message &lt;&lt; std::endl;
}

std::size_t Logger::getCount() const
{
    return counter_.load();
}

} // namespace singleton_example</pre>

    <p> &nbsp;</p>
    <p> ["singleton_pattern_01.cpp"]</p>
    
    <pre class="prettyprint linenums lang-cpp" style="width:1000px">
// singleton_pattern_01.cpp
// C++23 サンプル: スレッドセーフな Meyers スタイルのシングルトン（簡単な使用例）
// プロジェクト規約に従っています: 関数は camelCase、変数は snake_case、公開 API は Doxygen コメントを使用

#include &lt;iostream&gt;
#include &lt;thread&gt;       // for std::thread, std::this_thread::yield
#include &lt;vector&gt;       // for std::vector

#include "logger.h"

using singleton_example::Logger;

int main()
{
    // シングルトンへの同時アクセスを示すために複数スレッドを生成
    const int num_threads = 6;
    const int messages_per_thread = 5;

    std::vector&lt;std::thread&gt; threads;
    threads.reserve(num_threads);

    for (int t = 0; t &lt; num_threads; ++t) {
        threads.emplace_back([t, messages_per_thread]() {
            for (int i = 0; i &lt; messages_per_thread; ++i) {
                Logger::getInstance().log("thread " + std::to_string(t) + " message " + std::to_string(i));
                // 出力が混在する可能性を高めるために少し yield する
                std::this_thread::yield();
            }
        });
    }

    for (auto&amp; th : threads) {
        th.join();
    }

    std::cout &lt;&lt; "合計ログ数: " &lt;&lt; Logger::getInstance().getCount() &lt;&lt; std::endl;
    return 0;
}</pre>

    <p> &nbsp;</p>
    
    <p> ビルド方法：</p>
    <p> 上記3つのソースファイルを同じ場所に保存し、下記コマンドでビルドします。</p>
    <pre class="prettyprint lang-bsh" style="width:1000px">g++ -std=c++20 -Wall -Wextra -Wpedantic -pthread singleton_pattern_01.cpp logger.cpp -o singleton_pattern_01.out</pre>
    
    <p> &nbsp;</p>
    
    <p> 実行方法：</p>
    <pre class="prettyprint lang-sh" style="width:500px">./singleton_pattern_01.out</pre>
    
    <p> &nbsp;</p>
    
    <p> 実行結果：</p>
    <pre class="prettyprint lang-bsh" style="width:500px">
$ ./singleton_pattern_01.out 
[1] thread 0 message 0
[2] thread 0 message 1
[3] thread 1 message 0
[4] thread 1 message 1
[5] thread 1 message 2
[6] thread 1 message 3
[7] thread 0 message 2
[8] thread 0 message 3
[9] thread 3 message 0
[10] thread 4 message 0
[11] thread 4 message 1
[12] thread 4 message 2
[13] thread 4 message 3
[14] thread 4 message 4
[15] thread 0 message 4
[16] thread 2 message 0
[17] thread 2 message 1
[18] thread 2 message 2
[19] thread 2 message 3
[20] thread 2 message 4
[21] thread 3 message 1
[22] thread 3 message 2
[23] thread 3 message 3
[24] thread 3 message 4
[25] thread 1 message 4
[26] thread 5 message 0
[27] thread 5 message 1
[28] thread 5 message 2
[29] thread 5 message 3
[30] thread 5 message 4
合計ログ数: 30
$ </pre>

    <p> &nbsp;</p>
	
  </section>
  	
  <p> &nbsp;</p>
    
  <section>
    <h2> <a name="2._静的メンバ変数方式">2. 静的メンバ変数方式</a></h2>
  	<h4>[概要]</h4>
    <p> 「静的メンバ変数方式」と呼ばれるシングルトン型の <span class="cpp-source">Logger</span> 
    を紹介します。</p>
    <p> 主な特徴は以下の通りです。</p>
    <ul>
      <li>静的メンバ変数方式:<br><span class="cpp-source">Logger::getInstance()</span> 
      は、唯一のインスタンスである <span class="cpp-source">Logger::instance_ptr_</span> 
      を一度のみ初期化を行っています。<br>この初期化処理の部分がポイントです。</li>
      <li>&nbsp;スレッドセーフ: <br>内部で <span class="cpp-source">std::mutex</span> 
      を使って標準出力へのアクセスを直列化します</li>
      <li>破棄タイミング：<br>プログラムから明示的に <span class="cpp-source">
      Logger::destroyInstance();</span> を呼ぶ必要があります。</li>
      <li>基本 API: &nbsp;
      <ul>
        <li><span class="cpp-source">static Logger&amp;  getInstance()</span> : 
        シングルトンインスタンスを取得します</li>
        <li><span class="cpp-source">static void destroyInstance()</span> : 
        シングルトンインスタンスを破棄します</li>
        <li><span class="cpp-source">void log(const std::string&amp; message)</span> 
        : スレッドセーフにメッセージを標準出力へ出力し、内部カウンタを増加します</li>
        <li><span class="cpp-source">std::size_t getCount() const</span> : 
        これまでに出力したメッセージ数を返します</li>
      </ul>
      </li>
    </ul>
    <p>&nbsp;</p>
  
    <div class="status_information">
      <div></div>
      <div>
        <p><strong>NOTE</strong></p>
        <ul>
          <li>明示的に new で生成</li>
          <li>スレッドセーフではないので、ロックが必要</li>
          <li>破棄タイミングの制御が難しい</li>
        </ul>
      </div>
    </div>

    <p>&nbsp;</p>
  	<p> &nbsp;</p>
  	
  	<h4>[環境]</h4>
  	<table>
    	<tbody>
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>コンパイラ :</td>
    	      <td>g++</td>
    	      <td>13.3.0</td>
    	  </tr>
    		
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>OS :</td>
    	    <td>Ubuntu</td>
    	    <td>24.04.3 LTS</td>
    	  </tr>
    	  
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    	</tbody>
  	</table>
  	
	  <p> &nbsp;</p>
    <p> &nbsp;</p>
    <h4> [コード]</h4>
  	<p>[プログラムソース &quot;logger.h&quot;]</p>
    <pre class="prettyprint linenums lang-cpp" style="width:1000px">
// logger.h
// Logger クラスの宣言（ヘッダ）

#pragma once

#include &lt;atomic&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;

/**
 * @brief 明示的に破棄できるシングルトン Logger の宣言。
 *
 * 実装は logger.cpp にあり、スレッド安全な初期化と明示破棄をサポートします。
 */
class Logger {
private:
    // メンバー変数（先に記載）
<span class="auto-style1">    static std::unique_ptr&lt;Logger&gt; instance_ptr_;</span>
<span class="auto-style1">    static std::once_flag init_flag_;</span>

    mutable std::mutex mutex_;
    std::atomic&lt;std::size_t&gt; counter_{0};

<span class="auto-style1">    // unique_ptr のデフォルトデリータが private デストラクタを呼べるようにする</span>
<span class="auto-style1">    friend struct std::default_delete&lt;Logger&gt;;</span>

    // 特殊メンバはメソッド群の先頭に定義するが実装は cpp に置く
    Logger() = default;
    ~Logger() = default;

public:
    // コピー/ムーブを禁止
    Logger(const Logger&amp;) = delete;
    Logger&amp; operator=(const Logger&amp;) = delete;
    Logger(Logger&amp;&amp;) = delete;
    Logger&amp; operator=(Logger&amp;&amp;) = delete;

    /**
     * @brief シングルトンインスタンスを取得する。
     *
     * 初回呼び出し時にインスタンスを生成します（スレッド安全）。
     */
    static Logger&amp; getInstance();

<span class="auto-style1">    /**</span>
<span class="auto-style1">     * @brief シングルトンを明示的に破棄する。</span>
<span class="auto-style1">     *</span>
<span class="auto-style1">     * 注意: 破棄後に他スレッドが Logger を使用していると危険です。</span>
<span class="auto-style1">     */</span>
<span class="auto-style1">    static void destroyInstance();</span>

    /**
     * @brief メッセージをログ出力する（スレッドセーフ）。
     */
    void log(const std::string&amp; msg);

    /**
     * @brief これまでに出力したメッセージ数を返す。
     */
    std::size_t getCount() const;
};</pre>
    <p>&nbsp;</p>
    <p>[プログラムソース &quot;logger.cpp&quot;]</p>
    <pre class="prettyprint linenums lang-cpp" style="width:1000px">
// logger.cpp
#include "logger.h"

#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;
#include &lt;utility&gt;

// 静的メンバーの定義
<span class="auto-style1">std::unique_ptr&lt;Logger&gt; Logger::instance_ptr_;</span>
<span class="auto-style1">std::once_flag Logger::init_flag_;</span>

Logger&amp; Logger::getInstance()
{
<span class="auto-style1">    std::call_once(init_flag_, []() { instance_ptr_.reset(new Logger()); });</span>
<span class="auto-style1">    return *instance_ptr_;</span>
}

void Logger::destroyInstance()
{
<span class="auto-style1">    instance_ptr_.reset();</span>
}

void Logger::log(const std::string&amp; msg)
{
    std::lock_guard&lt;std::mutex&gt; lock(mutex_);
    ++counter_;
    std::cout &lt;&lt; "[" &lt;&lt; counter_ &lt;&lt; "] " &lt;&lt; msg &lt;&lt; std::endl;
}

std::size_t Logger::getCount() const
{
    return counter_.load();
}</pre>
    <p>&nbsp;</p>
    <p>[プログラムソース &quot;singleton_pattern_02.cpp&quot;]</p>
    <pre class="prettyprint linenums lang-cpp" style="width:1000px">
// singleton_pattern_02.cpp
// 明示的に破棄できるシングルトン（std::unique_ptr + std::call_once）
// サンプル実装：スレッド安全にログ出力し、必要なら明示破棄が可能

#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;

#include "logger.h"


int main()
{
    const int num_threads = 6;
    const int msgs_per_thread = 5;

    std::vector&lt;std::thread&gt; threads;
    threads.reserve(num_threads);

    for (int t = 0; t &lt; num_threads; ++t) {
        threads.emplace_back([t, msgs_per_thread]() {
            for (int i = 0; i &lt; msgs_per_thread; ++i) {
                Logger::getInstance().log("thread " + std::to_string(t) + " message " + std::to_string(i));
                std::this_thread::yield();
            }
        });
    }

    for (auto&amp; th : threads) {
        th.join();
    }

    std::cout &lt;&lt; "Total messages: " &lt;&lt; Logger::getInstance().getCount() &lt;&lt; std::endl;

    // 明示的に破棄する例（このプログラムでは不要だが動作する）
    <span class="auto-style1">Logger::destroyInstance();</span>

    return 0;
}</pre>

    <p>&nbsp;</p>
    
    <p>[プログラムソース &quot;Makefile&quot;]</p>
    <pre class="prettyprint linenums lang-cpp" style="width:1000px">
# Makefile for singleton_pattern_02 sample
#
# Targets:
#   all / build - build the executable
#   run         - run the built executable
#   clean       - remove built artifacts
#   help        - show this help

CXX := g++
CXXFLAGS := -std=c++23 -O2 -Wall -Wextra -pthread
LDFLAGS :=

SRC_DIR := .
SRCS := $(SRC_DIR)/logger.cpp $(SRC_DIR)/singleton_pattern_02.cpp
OBJS := $(SRCS:.cpp=.o)
TARGET := $(SRC_DIR)/singleton_pattern_02.out

.PHONY: all build run clean help

all: build

build: $(TARGET)

$(TARGET): $(SRCS)
	$(CXX) $(CXXFLAGS) -o $@ $(SRCS) $(LDFLAGS)

run: $(TARGET)
	@echo "Running $(TARGET)"
	$(TARGET)

clean:
	@echo "Cleaning..."
	-@rm -f $(TARGET) $(OBJS)

help:
	@echo "Makefile for singleton_pattern_02 sample"
	@echo "Available targets:"
	@echo "  make        (or make all)  - build the executable"
	@echo "  make run                   - run the executable (builds first if needed)"
	@echo "  make clean                 - remove build artifacts"
	@echo "  make help                  - show this message"</pre>
    <p>&nbsp;</p>
    
    <p>ビルド方法：</p>
    <p>make コマンドを実行するだけです</p>
    <pre class="prettyprint" style="width:800px">
$ make
g++ -std=c++23 -O2 -Wall -Wextra -pthread -o singleton_pattern_02.out ./logger.cpp ./singleton_pattern_02.cpp 
$</pre>
    <p>&nbsp;</p>
    
    <p>実行結果：</p>
    <pre class="prettyprint" style="width:800px">
$ ./singleton_pattern_02.out 
[1] thread 0 message 0
[2] thread 0 message 1
[3] thread 0 message 2
[4] thread 0 message 3
[5] thread 0 message 4
[6] thread 1 message 0
[7] thread 1 message 1
[8] thread 1 message 2
[9] thread 1 message 3
[10] thread 1 message 4
[11] thread 2 message 0
[12] thread 2 message 1
[13] thread 2 message 2
[14] thread 2 message 3
[15] thread 2 message 4
[16] thread 3 message 0
[17] thread 3 message 1
[18] thread 3 message 2
[19] thread 3 message 3
[20] thread 5 message 0
[21] thread 5 message 1
[22] thread 5 message 2
[23] thread 4 message 0
[24] thread 4 message 1
[25] thread 4 message 2
[26] thread 4 message 3
[27] thread 4 message 4
[28] thread 5 message 3
[29] thread 5 message 4
[30] thread 3 message 4
Total messages: 30
$ </pre>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>

    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p> &nbsp;</p>
  </section>
	
  <p> &nbsp;</p>

  <section>
    <h2> 3. ダブルチェックロッキング方式</h2>
  	<h4>[概要]</h4>
    <p>&nbsp;</p>
  
    <div class="status_information">
      <div></div>
      <div>
        <p><strong>NOTE</strong></p>
        <ul>
          <li>マルチスレッド環境での安全性を確保</li>
          <li>&nbsp;実装が複雑で、C++11 以降でも注意が必要</li>
        </ul>
      </div>
    </div>

    <p>&nbsp;</p>
  	<p> &nbsp;</p>
  	
  	<h4>[環境]</h4>
  	<table>
    	<tbody>
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>コンパイラ :</td>
    	      <td>g++</td>
    	      <td>13.3.0</td>
    	  </tr>
    		
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>OS :</td>
    	    <td>Ubuntu</td>
    	    <td>24.04.3 LTS</td>
    	  </tr>
    	  
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    	</tbody>
  	</table>
  	
	  <p> &nbsp;</p>
    <p> &nbsp;</p>
    <h4> [コード]</h4>
    
  	<p>[プログラムソース &quot;***.cpp&quot;]</p>
    <pre class="prettyprint linenums lang-cpp" style="width:1000px">
class Singleton {
private:
    static Singleton* instance;
    Singleton() = default;
    Singleton() = default;
public:
    // コピー/ムーブを削除してシングルトンを保証
    Singleton(const Logger&amp;) = delete;
    Singleton&amp; operator=(const Singleton&amp;) = delete;
    Singleton(Singleton&amp;&amp;) = delete;
    Singleton&amp; operator=(Singleton&amp;&amp;) = delete;

    static Singleton* getInstance() {
        if (!instance) {
            std::lock_guard&lt;std::mutex&gt; lock(mtx);
            if (!instance) {
                instance = new Singleton();
            }
        }
        return instance;
    }
};

Singleton* Singleton::instance = nullptr;
std::mutex mtx;</pre>

    <p>&nbsp;</p>
  </section>
	
  <p> &nbsp;</p>

  <section>
    <h2> 4. テンプレートベースの汎用シングルトン</h2>
  	<h4>[概要]</h4>
    <p>&nbsp;</p>
  
    <div class="status_information">
      <div></div>
      <div>
        <p><strong>NOTE</strong></p>
        <ul>
          <li>汎用的に使える</li>
          <li>&nbsp;<span class="cpp-source">T</span> によって異なる型のシングルトンを生成可能。 </li>
        </ul>
      </div>
    </div>

    <p>&nbsp;</p>
  	<p> &nbsp;</p>
  	
  	<h4>[環境]</h4>
  	<table>
    	<tbody>
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>コンパイラ :</td>
    	      <td>g++</td>
    	      <td>13.3.0</td>
    	  </tr>
    		
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    		
    	  <tr>
    	    <td>OS :</td>
    	    <td>Ubuntu</td>
    	    <td>24.04.3 LTS</td>
    	  </tr>
    	  
    	  <tr>
    	    <td class="td_separate" colspan="3"></td>
    	  </tr>
    	</tbody>
  	</table>
  	
	  <p> &nbsp;</p>
    <h4> [コード]</h4>
  	<p>[プログラムソース &quot;***.cpp&quot;]</p>
    <pre class="prettyprint linenums lang-cpp" style="width:1000px">
template &lt;typename T&gt;
class Singleton {
public:
    static T&amp; instance() {
        static T instance;
        return instance;
    }
};</pre>

    <p> &nbsp;</p>
  </section>
	
  <p> &nbsp;</p>

  <section>
    <h2><a id="ライセンス">ライセンス</a></h2>
    <p>本ページの情報は、特記無い限り下記 MIT ライセンスで提供されます。</p>
    <div class="license">
      The MIT License (MIT)<br><br>
      
      &nbsp; Copyright 2025 Kinoshita Hidetoshi<br><br>
      
      Permission is hereby granted, free of charge, to any person obtaining a copy
      of this software and associated documentation files (the "Software"), to deal
      in the Software without restriction, including without limitation the rights
      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      copies of the Software, and to permit persons to whom the Software is
      furnished to do so, subject to the following conditions:<br><br>
      
      The above copyright notice and this permission notice shall be included in all
      copies or substantial portions of the Software.<br><br>
      
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      SOFTWARE.
    </div>
    <p>&nbsp;</p>
  </section>
  
  <p> &nbsp;</p>
  
  <section>
  	<h2><a id="参考">参考</a></h2>
  	<ul>
  		<li>
        <a href="https://ja.wikipedia.org/wiki/デザインパターン_(ソフトウェア)" target="_blank">デザインパターン 
        (ソフトウェア) - Wikipedia</a></li>
        <li>
        <a href="https://ja.wikipedia.org/wiki/Singleton_パターン" target="_blank">
        Singleton パターン - Wikipedia</a></li>
  	</ul>
  </section>
  
  <p>&nbsp;</p>
  <hr>
  <p>&nbsp;</p>
  
  <section>
  	<h2 style="margin-bottom:5px">変更履歴</h2>
  	<table>
  	  <tr>
  	    <td class="td_history_date">2025-11-01</td>
  	    <td class="td_history_separator">-</td>
  	    <td class="td_history">新規作成 </td>
  	  </tr>
  	</table>
  </section>
  
  <p>&nbsp;</p>
  
  <section>
    <p><a href="../../index.html" target="_parent">Programming Items トップページ</a></p>
    <p><a href="../../privacy_policy.html">プライバシーポリシー</a></p>
  </section>
  
  <p>&nbsp;</p>
  
  <footer>
  	<p><small>&copy; 2025 Kinoshita Hidetoshi (木下英俊)</small></p>
  </footer>
  
</body>
</html>
