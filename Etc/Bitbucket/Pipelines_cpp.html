<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="kinoshita hidetoshi (木下 英俊)">
  <meta name="description" content="木下英俊が自身のためにプログラムメモを残すことを目的に作成したページです。">
  <meta name="keywords" content="">
  <!-- キャッシュ無効化 -->
  <meta http-equiv="Cache-Control" content="no-cache">
	
  <!-- タイトル -->
  <title>[Bitbucket Pipelines] c++(g++) をビルドする | Programming Items</title>
	
  <!-- ファビコン -->
  <link rel="shortcut icon" href="../../favicon.ico">
  
  <!-- CSS -->
  <link href="https://unpkg.com/ress/dist/ress.min.css" rel="stylesheet">
	<link rel="stylesheet" href="../../design.css" type="text/css">
  
	<!-- Start for 'google-code-prettify' -->
	<link href="../../prettify/styles/desert.css" rel="stylesheet" type="text/css">
	<script src="../../prettify/prettify.js" type="text/javascript"></script>
	<script src="../../prettify/lang-yaml.js" type="text/javascript"></script>
	<!-- End for 'google-code-prettify' -->	
	
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-V2DZQK54C2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'G-V2DZQK54C2');
  </script>
  <!-- Global site tag (gtag.js) - Google Analytics -->

  <style type="text/css">
  .auto-style1 {
    color: #FF0000;
  }
  .auto-style2 {
    background-color: #505000;
  }
  .auto-style3 {
    text-decoration: underline;
  }
  </style>

</head>

<body onload="prettyPrint();">
	
  <h1>[Bitbucket Pipelines] c++(g++) をビルドする</h1>
  <p><strong>Bitbucket Pipelines</strong> を使って c++(g++) をビルドする手順について記載します。</p>
  <p>&nbsp;</p>

  <div class="mokuji">
    <nav>
    	<h2>目次</h2>
    	<p><a href="#1._事前準備">1. 事前準備</a></p>
      <p>&nbsp;&nbsp; <a href="#1-1._リポジトリを作成">1-1. リポジトリを作成</a></p>
      <p>&nbsp;&nbsp; <a href="#1-2._リポジトリをクローン">1-2. リポジトリをクローン</a></p>
      <p>&nbsp;&nbsp; <a href="#1-3._サンプルソース（c++）を作成">1-3. サンプルソース (c++) を作成</a></p>
      <p>&nbsp;&nbsp; <a href="#1-4._コミット＆プッシュ">1-4. コミット＆プッシュ</a></p>
      <p>&nbsp;&nbsp; <a href="#1-5._Pipelines_を有効化">1-5. Pipelines を有効化</a> </p>
    	<p><a href="#2._ビルドする">2. ビルドする</a></p>
      <p>&nbsp;&nbsp; <a href="#2-1._image_を_ubuntu:18.04_に設定">2-1. image を ubuntu:18.04 に設定</a></p>
      <p>&nbsp;&nbsp; <a href="#2-2._開発環境（gcc/g++_など_－_“build-essential”）をインストール">2-2. 開発環境（gcc/g++ など － "build-essential"）をインストール</a></p>
      <p>&nbsp;&nbsp; <a href="#2-3._ソースコードをビルドする">2-3. ソースコードをビルドする</a></p>
      <p>&nbsp;&nbsp; <a href="#2-4._“parallel”_処理をやめて同時実行を１つのみに修正">2-4. "parallel" 処理をやめて同時実行を1つのみに修正</a></p>
      <p>&nbsp;&nbsp; <a href="#2-5._以上の修正を実施後の_bitbucket-pipelines.yml">2-5. 以上の修正を実施後の "bitbucket-pipelines.yml"</a></p>
    	<p><a href="#3._アーティファクトを登録する">3. アーティファクトを登録する</a></p>
      <p><a href="#4._デプロイする">4. デプロイする</a></p>
      <p>&nbsp;&nbsp; <a href="#4-1._ステップ１：_リポジトリ所有者向けにアプリパスワードを作成する">4-1. ステップ１: リポジトリ所有者向けにアプリパスワードを作成する</a></p>
      <p>&nbsp;&nbsp; <a href="#4-2._ステップ２：_認証トークンを使用して_Pipelines_変数を作成する">4-2. ステップ２: 認証トークンを使用して Pipelines 変数を作成する</a></p>
      <p>&nbsp;&nbsp; <a href="#4-3._ステップ３a：_Bitbucket-upload-file_パイプを使用したアーティファクトのデプロイ">4-3. ステップ３a: Bitbucket-upload-file パイプを使用したアーティファクトのデプロイ</a></p>
      <p>&nbsp;&nbsp; <a href="#4-4._ステップ３b：_curl_および_Bitbucket_REST_API_を使用したアーティファクトのデプロイ">4-4. ステップ３b: curl および Bitbucket REST API を使用したアーティファクトのデプロイ</a></p>
      <p>&nbsp;&nbsp; <a href="#4-5._(参考)_curl_コマンドでダウンロードへ登録したファイルを取得する">4-5. (参考) curl コマンドでダウンロードへ登録したファイルを取得する</a></p>
      <p><a href="#5._パイプライントリガー">5. パイプライントリガー</a></p>
      <p>&nbsp;&nbsp; <a href="#5-1._手動でパイプラインを実行する">5-1. 手動でパイプラインを実行する</a></p>
      <p>&nbsp;&nbsp; <a href="#5-2._特定ブランチへのコミットをトリガーにパイプラインを実行する">5-2. 特定ブランチへのコミットをトリガーにパイプラインを実行する</a></p>
      <p>&nbsp;&nbsp; <a href="#5-3._Pull_Request_をトリガーにパイプラインを実行する">5-3. Pull Request をトリガーにパイプラインを実行する</a></p>
      <p>&nbsp;&nbsp; <a href="#5-4._スケジュールでパイプラインを実行する">5-4. スケジュールでパイプラインを実行する</a></p>
        <p><a href="#6._パイプラインで_git_clone_する">6. パイプラインで git clone する</a></p>
        <p><a href="#7._アーティファクトのファイル名にビルド番号を付ける">7. アーティファクトのファイル名にブル度番号を付ける</a></p>
        <p><a href="#8._ユニットテストを行う">8. ユニットテストを行う</a></p>
        <p><a href="#9._ユニットテストへ動的解析を加える_(Valgrind)">9. ユニットテストへ動的解析を加える (Valgrind)</a></p>
        <p><a href="#10._ユニットテストへソースコードカバレッジを加える">10. ユニットテストへソースコードカバレッジを加える</a></p>
        <p><a href="#11._静的解析を行う_(cppcheck)">11. 静的解析を行う (cppcheck)</a></p>
        <p><a href="#Appendix">Appendix</a></p>
        <p>&nbsp;&nbsp; <a href="#A.1._Pipelines_の_step_における失敗によるスクリプト停止を避ける方法">A.1. Pipelines の step における失敗よるスクリプト停止を避ける方法</a></p>
        <p>&nbsp;&nbsp; <a href="#A.2._Pipelines_最長実行時間を変更する方法">A.2. Pipelines 最長実行時間を変更する方法</a></p>
    	<p>&nbsp;</p>
    	<p><a href="#ライセンス">ライセンス</a></p>
    	<p><a href="#参考">参考</a></p>
    </nav>
  </div>

  <p>&nbsp;</p>
  <p>&nbsp;</p>

  <section>
  	<h2> <a name="1._事前準備">1. 事前準備</a></h2>
    <h3><a name="1-1._リポジトリを作成">1-1. リポジトリを作成</a></h3>
    <p>リポジトリを作成します。詳細割愛。</p>
    <p>
    &nbsp;</p>
    
    <h3><a name="1-2._リポジトリをクローン">1-2. リポジトリをクローン</a></h3>
    <p>リポジトリをローカルＰＣへクローンします。</p>
    <p><img alt="git clone" src="Pipelines_cpp/img2E.jpg" width="1000"></p>
    <p>&nbsp;</p>
    
    <h3><a name="1-3._サンプルソース（c++）を作成">1-3. サンプルソース（c++）を作成</a></h3>
    <p>ソースコードを作成します。下記は例です。</p>
    <p>
    <img alt="sample source" src="Pipelines_cpp/img30.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>プログラム例（”hello.cpp”） </p>
    <pre class="prettyprint linenums lang-cpp" style="width: 600px">
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; "Hello world." &lt;&lt; std::endl;
    return EXIT_SUCCESS;
}</pre>
    <p>&nbsp;</p>
    
    <h3><a name="1-4._コミット＆プッシュ">1-4. コミット＆プッシュ</a></h3>
    <p>作成したソースコードをコミット＆プッシュします。 </p>
    <p><img alt="コミット＆プッシュ" src="Pipelines_cpp/img3C.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p><img alt="コミット＆プッシュ" src="Pipelines_cpp/img3D.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>クラウド側に登録を完了 </p>
    <p>
    <img alt="コミット＆プッシュ" class="border" src="Pipelines_cpp/img3E.jpg" width="1000"></p>
    <p>&nbsp;</p>
    
    <h3><a name="1-5._Pipelines_を有効化">1-5. Pipelines を有効化</a></h3>
    <p>以下の手順で Pipelines を有効化します。 </p>
  
    <div class="status_information">
      <div></div>
      <div>
        <p><strong>NOTE</strong></p>
        <p>リポジトリの管理者権限を持つ人のみが以下を実施可能です。</p>
      </div>
    </div>

    <p>&nbsp;</p>
    <p>(1) ”Repository settings” をクリックします。 </p>
    <p>
    <img alt="Repository settings" class="border" src="Pipelines_cpp/img51.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>(2) “PIPELINES“ の中の "Settings“ をクリックします。</p>
    <p>
    <img alt="Settings" class="border" src="Pipelines_cpp/img53.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>(3) “Enable Pipelines“ をチェック状態にします。 </p>
    <p>
    <img alt="Enable Pipelines" class="border" src="Pipelines_cpp/img54.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>これで Pipelines が有効になりました。 </p>
    <p>&nbsp;</p>
    <p>(4) ”bitbucket-pipelines.yml” の雛形を準備します。ここでは下記手順で雛形を準備してみました。 </p>
    <p>「パイプライン」⇨「Build C++ Application」 </p>
    <p>
    <img alt="Build C++ Application" class="border" src="Pipelines_cpp/img56.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>内容を確認後［Commit file］ボタンをクリックします。 </p>
    <p>
    <img alt="Commit file" class="border" src="Pipelines_cpp/img58.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>すると・・・初めての Pipelines が実行されました。 </p>
    <p>&nbsp;</p>
    <p>
    <img alt="Start Pipelines" class="border" src="Pipelines_cpp/img5B.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>当然ながら <span class="auto-style1"><strong>Failed</strong></span> となりました。 
    </p>
    <p>&nbsp;</p>
    <p>こんなメールが私へ届きました。これは良いですね。</p>
    <p>複数メンバーがいるときなど、このメールは誰に対して送信されるのかが気になりましたが、ここでは一旦忘れて進めます。 </p>
    <p>
    <img alt="mail 受信" class="border_with_drop-shadow" src="Pipelines_cpp/img5E.jpg" width="600"></p>
    <p>&nbsp;</p>
    <p>”パイプライン” メニューをクリックすると Status が ”<span class="auto-style1"><strong>Failed</strong></span>” 
    のものがあります。 </p>
    <p>
    <img alt="Failed on pipeline menu" class="border" src="Pipelines_cpp/img5F.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>クリックして内容を確認してみると・・・ make に check の記載がされていない ・・・ということらしいです。そもそも makefile 
    を準備していないので、エラーになって当然の状況です。</p>
    <p>
    <img alt="Cause of error" class="border" src="Pipelines_cpp/img62.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>「ソース」を確認すると、とりあえず ”bitbucket-pipelines.yml” ファイルが追加されています。 </p>
    <p>
    <img alt="bitbucket-pipelines.yml" class="border" src="Pipelines_cpp/img64.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>現時点の yml ファイル内容を以下に記載します。今後このファイルを編集していくことで Pipelines を実際に動くようにしていきます。</p>
    
    <p>["bitbucket-pipelines.yml"]</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px">
# Template C++ Application

# This template allows you to validate your C++ application.
# The workflow allows running tests and code linting on the default branch.


image: gcc:10.2


pipelines:
  default:
    - parallel:
        - step:
            name: Test
            script:
              - make check
        - step:
            name: Lint
            script:
              # apt update &amp;&amp; apt -y install cppcheck &amp;&amp; cppcheck .
              - make lint
        - step:
            name: Build and Run
            script:
              - make compile
              # Execute your C++ application after compilation to check success
              - make distcheck</pre>
    <p>&nbsp;</p>
    <p>以上で 事前準備 を完了とします。</p>
  </section>
    
  <p>&nbsp;</p>
  <hr>
  <p>&nbsp;</p>
    
  <section>
    <h2><a name="2._ビルドする">2. ビルドする</a></h2>
    <p>“bitbucket-pipelines.yml” を編集することで、基本的なビルド＆デプロイを実装していきます。</p>
    <p>&nbsp;</p>
    
    <h3><a name="2-1._image_を_ubuntu:18.04_に設定">2-1. image を ubuntu:18.04 に設定</a></h3>
    <p>ここでは例として実行環境（Docker Image）を ubuntu:18.04 に設定します。</p>
    <p>（新）<span class="cpp-source">image: ubuntu:18.04</span> </p>
    <p>（旧）<span class="cpp-source">image: gcc:10.2</span> </p>
    <p>ちゃんと “Ubuntu 18.04” になったか確認のため、"<span class="cpp-source">cat 
    /etc/lsb-release"</span> の一文も追加します。 </p>
    <p>&nbsp;</p>
    
    <h3><a name="2-2._開発環境（gcc/g++_など_－_“build-essential”）をインストール">2-2. 開発環境（gcc/g++ など － “build-essential”）をインストール</a></h3>
    <p>下記２行を追加します。</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px">
- apt-get update
- apt-get -y install build-essential</pre>
    <p>&nbsp;</p>
    
    <h3><a name="2-3._ソースコードをビルドする">2-3. ソースコードをビルドする</a></h3>
    <p>下記１行を追加します。</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px">
- g++ hello.cpp -o hello</pre>
    <p>&nbsp;</p>
    
    <h3><a name="2-4._“parallel”_処理をやめて同時実行を１つのみに修正">2-4. “parallel” 処理をやめて同時実行を１つのみに修正</a></h3>
    <p>Pipelines の実施をシンプルにすることを目的に、”Test” の step のみを残して他の step 
    を削除して簡略化します。詳細説明を割愛。修正後の内容は後述の ”bitbucket-pipelines.yml” を参照。</p>
    <p>（parallel は高速な実行を実現できるとても魅力的な機能ですが、この機能を使用するのは Pipelines 
    をある程度使用できるようになってから検討しましょう。）</p>
    <p>&nbsp;</p>
    
    <h3><a name="2-5._以上の修正を実施後の_bitbucket-pipelines.yml">2-5. 以上の修正を実施後の "bitbucket-pipelines.yml"</a></h3>
    <p>以上の修正を行った結果の ”bitbucket-pipelines.yml” を以下に示します。 </p>
    <p>["bitbucket-pipelines.yml"]</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px">
image: ubuntu:18.04

pipelines:
  default:
    - step:
        name: Build
        script:
          - cat /etc/lsb-release
          - apt-get update
          - apt-get -y install build-essential
          - g++ hello.cpp -o hello</pre>
    <p>&nbsp;</p>
    <p>上記修正で Pipelines 実行を正常に完了できるようになりました。OS も “Ubuntu 18.04.6 LTS“ 
    を意図通りにロードできていることを確認できました。</p>
    <p>
    <img alt="Pipelines 実行 Success" src="Pipelines_cpp/img86.jpg" class="border" width="1000"></p>
    <p>&nbsp;</p>
    <p>本書記載時点、正常終了した Pipelines に対するメールは届きませんでした。</p>
    <p>&nbsp;機能拡張「Jira and Bitbucket (Atlassian Labs)」をインストールした “VS code” 
    から正常終了した Pipelines を下図のように確認することができました。</p>
    <p><img alt="VS code の様子" src="Pipelines_cpp/img88.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>以上で正常動作する “bitbucket-pipelines.yml” を構築できました。</p>
    <p>&nbsp;この後は少しずつ機能を加えていく感じで修正を行っていきたいと思います。 </p>
  </section>
    
  <p>&nbsp;</p>
  <hr>
  <p>&nbsp;</p>
  
  <section>
    <h2><a name="3._アーティファクトを登録する">3. アーティファクトを登録する</a></h2>
    <p>
    アーティファクトは、ステップによって作成されるファイルです。パイプライン設定で定義したら、以降のステップで共有したり、エクスポートしてステップの完了後にアーティファクトを保持したりすることができます。たとえば、ビルド 
    ステップで生成された JAR ファイルまたはレポートを、後のデプロイメント 
    ステップで使用できます。ステップで生成されたアーティファクトをダウンロードしたり、外部ストレージにアップロードすることもできます。 </p>
    <p>次の点に留意する必要があります。</p>
    <ul>
      <li>&nbsp;ステップの最後に <strong>BITBUCKET_CLONE_DIR</strong> 
      にあるファイルをアーティファクトとして構成できます。<strong>BITBUCKET_CLONE_DIR</strong> 
      は、リポジトリが最初にクローンされるディレクトリです。</li>
      <li>glob パターンを使用してアーティファクトを定義できます。* で開始される glob パターンは、引用句で囲む必要があります。<br>注: 
      これらは glob パターンのため、パス セグメント "." および ".." を使用できません。ビルド ディレクトリに相対的なパスを使用します。 
      </li>
      <li>アーティファクトのパスは、<strong>BITBUCKET_CLONE_DIR </strong>からの相対パスになります。 </li>
      <li>ステップ中で作成されたアーティファクトは、以降のすべてのステップで使用できます。 </li>
      <li>アーティファクトは、生成から 14 日後に削除されます。 </li>
      <li>アーティファクトは、１ファイル当たりのファイルサイズ 1GB 
      という上限があります。このサイズを超えるファイルをアーティファクトとして登録できません。 </li>
    </ul>
    <p>&nbsp;</p>
    <p>ここまで作成した “bitbucket-pipelines.yml“ にアーティファクト指定を加えてみます。 </p>
    <p>["bitbucket-pipelines.yml"] ファイルをアーティファクトへ登録した例</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px">
image: ubuntu:18.04

pipelines:
  default:
    - step:
        name: Build
        script:
          - cat /etc/lsb-release
          - apt-get update
          - apt-get -y install build-essential
          - g++ hello.cpp -o hello
<span class="auto-style2">        artifacts:</span>
<span class="auto-style2">          - hello</span></pre>
    <p>&nbsp;</p>
    <p>["bitbucket-pipelines.yml"] フォルダーをアーティファクトへ登録した例</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px">
image: ubuntu:18.04

pipelines:
  default:
    - step:
        name: Build
        script:
          - cat /etc/lsb-release
          - apt-get update
          - apt-get -y install build-essential zip
          - mkdir out
          - g++ hello.cpp -o out/hello
<span class="auto-style2">        artifacts:</span>
<span class="auto-style2">          - out/**</span></pre>
    <p>&nbsp;</p>
    <p>パイプラインを実行後の画面です。”Artifacs” の画面から “hello“ をダウンロードすることができます。</p>
    <p>
    <img alt="Artifact" class="border" src="Pipelines_cpp/img91.jpg" width="800"></p>
    <p>&nbsp;</p>
    <p><strong>参考：</strong></p>
    <ul>
      <li>
      <a href="https://ja.confluence.atlassian.com/bitbucket/using-artifacts-in-steps-935389074.html#Usingartifactsinsteps-artifact_expiry" target="_blank">Using artifacts in steps | Bitbucket Cloud | Atlassian Documentation</a></li>
    </ul>
    <p>&nbsp;</p>
  </section>
    
  <p>&nbsp;</p>
  <hr>
  <p>&nbsp;</p>

  <section>
    <h2><a name="4._デプロイする">4. デプロイする</a></h2>
    <p>アーティファクトは保存期間14日以内という制約がありました。<br>アーティファクトを14日以上保存する必要がある場合は他の場所へ<strong>デプロイ</strong>する必要があります。</p>
    <p>AWS へ保存する、ftp で保存する、など様々な方法を Bitbucket 
    は提供していますが、ここでは「ダウンロード」メニューからビルド結果を取得できるようにする方法を紹介します。<br>言い換えると、Pipelines 
    にダウンロードサイトへ <strong>デプロイ</strong> する処理を追加します。 </p>
    <p>&nbsp;</p>
    
    <h3><a name="4-1._ステップ１：_リポジトリ所有者向けにアプリパスワードを作成する">4-1. ステップ１： リポジトリ所有者向けにアプリパスワードを作成する</a></h3>
    <p>アプリパスワードを作成します。</p>
    <p>&nbsp;</p>
    <p>(1) Bitbucket にログイン後、①設定アイコン 、②［<strong>Personal Bitbucket settings</strong>］を順にクリックします。</p>
    <p>
    <img alt="Personal Bitbucket settings" class="border" src="Pipelines_cpp/img5.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>(2) メニューから [<strong>アクセス管理</strong>] のグループ中にある［<strong>アプリパスワード</strong>］を選択します。</p>
    <p>
    <img alt="アプリパスワード" class="border" src="Pipelines_cpp/img6.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>(3) [<strong>アプリパスワードの作成</strong>] ボタンをクリックします。</p>
    <p>&nbsp;</p>
    <p>(4) 下図中の ①、② を記入後、③をクリックします。</p>
    <p>①の Label はユーザーの識別用に使用されるため「Pipelines」などの任意の名前を設定できます。</p>
    <p>ここでは評価に使用しているリポジトリ名をそのまま使用します。 </p>
    <p>
    <img alt="アプリパスワード" class="border" src="Pipelines_cpp/img7.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>(5) 「新しいアプリ パスワード」を表示するので記録します。</p>
    <p><img alt="新しいアプリパスワード" src="Pipelines_cpp/img8.jpg"></p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    
    <h3><a name="4-2._ステップ２：_認証トークンを使用して_Pipelines_変数を作成する">4-2. ステップ２： 認証トークンを使用して Pipelines 変数を作成する</a></h3>
    <p>Bitbucket Downloads にファイルをアップロードするには、以下の変数を設定する必要があります。</p>
    <p>&nbsp;</p>
        
    <table class="border-collapse" border="1" width="600">
      <caption></caption>
      <thead class="standard_table">
        <tr>
          <th>パラメータ名</th>
          <th>値</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>BITBUCKET_USERNAME</strong></td>
          <td>リポジトリを所有、かつアーティファクトをアップロードするユーザーの Bitbucket ユーザー名 </td>
        </tr>
        <tr>
          <td style="white-space:nowrap"><strong>BITBUCKET_APP_PASSWORD </strong> </td>
          <td>Bitbucket が生成したアプリパスワード </td>
        </tr>
      </tbody>
    </table>
    
    <p>&nbsp;</p>
    <p>(1) リポジトリの設定で、特定のデプロイメント環境に対してこれらの変数を定義します。</p>
    <p>&nbsp;［<strong>Repository settings</strong>］ &gt; “PIPELINES“ の［<strong>Repository 
    variables</strong>］ をクリックします。</p>
    <p>
    <img alt="Repository variables" class="border" src="Pipelines_cpp/img14.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>(2) 下記内容を "Repository variables" へ登録します。</p>
        
    <table class="border-collapse" border="1" width="600">
      <caption></caption>
      <thead class="standard_table">
        <tr>
          <th>Name</th>
          <th>Value</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>BITBUCKET_USERNAME</strong></td>
          <td>リポジトリを所有、かつアーティファクトをアップロードするユーザーの Bitbucket ユーザー名 </td>
        </tr>
        <tr>
          <td style="white-space:nowrap"><strong>BITBUCKET_APP_PASSWORD </strong> </td>
          <td>Bitbucket が生成したアプリパスワード </td>
        </tr>
      </tbody>
    </table>
    
    <p>&nbsp;</p>
    
    <div class="status_warning">
      <div></div>
      <div>
        <p><strong>重要</strong></p>
        <p>BITBUCKET_USERNAME として設定するのは、下図赤枠に表示の "<strong>ユーザー名</strong>"<strong>
        </strong>です。その上の "<strong>名前</strong>" ではありません。</p>
      </div>
    </div>

    <p>&nbsp;</p>
    <p>
    <img alt="BITBUCKET_USERNAME" class="border" src="Pipelines_cpp/img17.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>設定後の様子(例)です。</p>
    <p>
    <img alt="Repository variables" class="border" src="Pipelines_cpp/img18.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    
    <h3><a name="4-3._ステップ３a：_Bitbucket-upload-file_パイプを使用したアーティファクトのデプロイ">4-3. ステップ３a： Bitbucket-upload-file パイプを使用したアーティファクトのデプロイ</a></h3>
    <p>アーティファクトを Bitbucket Downloads にアップロードするには、<a href="https://bitbucket.org/atlassian/bitbucket-upload-file" target="_blank">bitbucket-upload-file</a> 
    パイプを使用します。必要な作業は、アップロードするファイルをビルドのアウトプットから参照するだけです。</p>
    <ul>
      <li>FILENAME には “glob patterns“ を使用できます。例えば ‘*.html’ や '**/*.txt' 
      というような表記をあなたは使用することができます。ただし最大10ファイルまで。もし上限に達した場合はビルドエラーになる、と説明に記載されていました。</li>
      <li>&nbsp;<a href="https://bitbucket.org/atlassian/bitbucket-upload-file/src/master/">bitbucket-upload-file</a> 
      の使用方法など、詳細な説明は 
      <a href="https://bitbucket.org/atlassian/bitbucket-upload-file/src/master/">
      こちら</a> を参照ください。</li>
    </ul>
    <p>ここまでに作成した “bitbucket-pipelines.yml“ へ “bitbucket-upload-file“ 
    パイプの処理を追加します。ここでは “step” を加える形で追加してみます。 “name: Deploy“ としました。</p>
    <p>&nbsp;下記例で FILENAME をフルパス表記で記載していますが、説明資料を見る限り ${BITBUCKET_CLONE_DIR} 
    からの相対パスの表記で大丈夫そうです。ただし私は未確認ですのでご自身で試してみてください。 </p>
    <p>&nbsp;</p>
    <p>["bitbucket-pipelines.yml"]</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px">
image: ubuntu:18.04

pipelines:
  default:
    - step:
        name: Build
        script:
          - cat /etc/lsb-release
          - apt-get update
          - apt-get -y install build-essential
          - g++ hello.cpp -o hello
        artifacts:
          - hello
<span class="auto-style2">    - step:</span>
<span class="auto-style2">        name: Deploy</span>
<span class="auto-style2">        script:</span>
<span class="auto-style2">          - echo $BITBUCKET_CLONE_DIR</span>
<span class="auto-style2">          - pipe: atlassian/bitbucket-upload-file:0.3.3</span>
<span class="auto-style2">            variables:</span>
<span class="auto-style2">              BITBUCKET_USERNAME: $BITBUCKET_USERNAME</span>
<span class="auto-style2">              BITBUCKET_APP_PASSWORD: $BITBUCKET_APP_PASSWORD</span>
<span class="auto-style2">              FILENAME: "${BITBUCKET_CLONE_DIR}/hello"</span></pre>
    <p>&nbsp;</p>
  
    <div class="status_information">
      <div></div>
      <div>
        <p><strong>NOTE</strong></p>
        <p>“BITBUCKET_CLONE_DIR“ はカレントパスを示す変数です。これを使用することでフルパス表記で FILENAME 
        を記載しています。詳細は資料 “<a href="https://ja.confluence.atlassian.com/bitbucket/variables-in-pipelines-794502608.html" target="_blank">Variables 
        in pipelines | Bitbucket Cloud | Atlassian Documentation</a>” 
        を参照してください。パイプラインで使用できる他の変数も確認することができます。 </p>
      </div>
    </div>

    <p>&nbsp;</p>
    
    <div class="status_warning">
      <div></div>
      <div>
        <p><strong>注意</strong></p>
        <p>2022/10/14 時点、スクリプト最新バージョンは 0.3.3 
        です。時々バージョンアップを行うようなので、注意しつつ原則最新版の使用をご検討ください。</p>
        <p><span class="cpp-source">- pipe: 
        atlassian/bitbucket-upload-file:0.3.3</span></p>
      </div>
    </div>

    <p>&nbsp;</p>
    <p>この “bitbucket-pipelines.yml“ によりパイプラインを実行した結果を以下に記載します。</p>
    <p>こちらは パイプライン実行を成功 (Successful) した例です。</p>
    <p><img alt="パイプライン実行を成功 (Successful) した例" src="Pipelines_cpp/wp28jh6u.jpg" class="border" width="1000">&nbsp;</p>
    <p>&nbsp;</p>
    <p>
    <img alt="pipelines" class="border" src="Pipelines_cpp/img22.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>［ダウンロード］をクリックすると、”hello” をダウンロードできるようになっていることを確認できます。</p>
    <p>
    <img alt="ダウンロード" class="border" src="Pipelines_cpp/img24.jpg" width="1000"></p>
    <p>&nbsp;</p>
  
    <div class="status_information">
      <div></div>
      <div>
        <p><strong>NOTE</strong></p>
        <p>複数のファイルを登録する場合、事前に zip コマンドで圧縮したファイルを登録することを推奨します。 </p>
      </div>
    </div>

    <p>&nbsp;</p>
    <p>&nbsp;</p>
    
    <h3><a name="4-4._ステップ３b：_curl_および_Bitbucket_REST_API_を使用したアーティファクトのデプロイ">
    4-4. ステップ３b： curl および Bitbucket REST API を使用したアーティファクトのデプロイ</a></h3>
    <p>前述「ステップ３a」の pipe 処理部分を curl コマンドにより実行する方法を紹介します。</p>
    <p>詳細は 
    <a href="https://support.atlassian.com/ja/bitbucket-cloud/docs/deploy-build-artifacts-to-bitbucket-downloads/" target="_blank">
    こちら</a> 資料の「ステップ３ｂ」を参照ください。</p>
    <p>&nbsp;</p>
    <p>["bitbucket-pipelines.yml"]</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px; white-space: pre-wrap;">
image: ubuntu:18.04

pipelines:
  default:
    - step:
        name: Build
        script:
          - cat /etc/lsb-release
          - apt-get update
          - apt-get -y install build-essential
          - g++ hello.cpp -o hello
        artifacts:
          - hello
    - step:
        name: Deploy
        script:
          - echo $BITBUCKET_CLONE_DIR
          - <span class="auto-style2">curl -X POST "https://${BITBUCKET_USERNAME}:${BITBUCKET_APP_PASSWORD}@api.bitbucket.org/2.0/repositories/${BITBUCKET_REPO_OWNER}/${BITBUCKET_REPO_SLUG}/downloads" --form files=@"hello"</span></pre>
    <p>&nbsp;</p>
  
    <div class="status_information">
      <div></div>
      <div>
        <p><strong>NOTE</strong></p>
        <p>Atlassian ドキュメント中に変数 <span class="cpp-source"><strong>
        BITBUCKET_REPO_OWNER</strong></span> の説明を見つけられませんでしたが、上記 YAML 
        コードでちゃんと動作することを確認できました。 </p>
      </div>
    </div>

    <p>&nbsp;</p>
  
    <div class="status_information">
      <div></div>
      <div>
        <p><strong>NOTE</strong></p>
        <p>REST API 詳細については 
        <a href="https://developer.atlassian.com/cloud/bitbucket/rest/api-group-downloads/#api-group-downloads" target="_blank">
        The Bitbucket Cloud REST API (atlassian.com)</a> を参照ください。 </p>
      </div>
    </div>

    <p>&nbsp;</p>
    <p>&nbsp;</p>
    
    <h3><a name="4-5._(参考)_curl_コマンドでダウンロードへ登録したファイルを取得する">4-5. (参考) curl コマンドでダウンロードへ登録したファイルを取得する</a></h3>
    <p>ダウンロードへ登録したファイルを下記 <strong>curl</strong> 
    コマンドによりダウンロードすることができます。任意の端末からダウンロードする、各種自動化などで活用する、Pipelines 
    実行時にビルド済み最新ライブラリを別リポジトリからダウンロードしてくる、など活用の可能性がいろいろありそうです。 </p>
    <p>&nbsp;</p>
    <p>■一般書式１</p>
    <pre style="color: #FFFFFF; background-color: #000000">curl --user $USER_ID:$APP_PASSWORD -s -L https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/downloads/{filename} -o {filename}</pre>
    <p>■一般書式２</p>
    <pre style="color: #FFFFFF; background-color: #000000">curl --user $USER_ID:$APP_PASSWORD -s -L https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/downloads/{filename} &gt; {filename}</pre>
    <p>&nbsp;</p>
    <p>■具体例</p>
        
    <table class="border-collapse" border="1" width="800">
      <caption></caption>
      <thead class="standard_table">
        <tr>
          <th>項目</th>
          <th>説明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>$USER_ID</td>
          <td>ログインユーザのIDを記載します。ここでは私のID Hidetoshi_Kinoshita を例示します。</td>
        </tr>
        <tr>
          <td style="white-space:nowrap">$APP_PASSWORD</td>
          <td>$USER_ID で取得済みのアプリパスワードです。例示では **** としていますが実際に使用時は取得したパスワードを入力します。<br>
          アプリパスワードの権限はリポジトリへ "書き込み" でテストしましたが、ファイル取得だけなら "読み取り" 権限だけでも良いかもしれません。<br>
          basic 認証では正常に動作しませんでした。アプリパスワードを使う必要があります。 </td>
        </tr>
        <tr>
          <td>{workspace}</td>
          <td>ワークスペース名を記載します。下記例では "Hidetoshi_Kinoshita" を指定しています。</td>
        </tr>
        <tr>
          <td>{repo_slug}</td>
          <td>リポジトリ名を記載します。下記例では "test_repository" を指定しています。</td>
        </tr>
        <tr>
          <td>{filename}</td>
          <td>取得するファイル名です。 下記では "hello" を指定しています。</td>
        </tr>
      </tbody>
    </table>
    
    <p>&nbsp;</p>
    <pre style="color: #FFFFFF; background-color: #000000">curl --user Hidetoshi_Kinoshita:************************************ -s -L https://api.bitbucket.org/2.0/repositories/Hidetoshi_Kinoshita/test_repository/downloads/hello -o hello</pre>
    <p>&nbsp;</p>
    <p>※ 上記コマンドによる動作確認は、Ubuntu 22.04 にて行いました。</p>
    <p>&nbsp;</p>
    <p><strong>参考：</strong></p>
    <ul>
      <li>&nbsp;<a href="https://support.atlassian.com/ja/bitbucket-cloud/docs/deploy-build-artifacts-to-bitbucket-downloads/">Bitbucket 
      ダウンロードにビルド アーティファクトをデプロイする | Bitbucket Cloud | アトラシアン サポート (atlassian.com)</a>
      </li>
      <li>
      <a href="https://bitbucket.org/atlassian/bitbucket-upload-file/src/master/">
      atlassian / bitbucket-upload-file — Bitbucket</a> </li>
      <li>
      <a href="https://developer.atlassian.com/cloud/bitbucket/rest/api-group-downloads/#api-group-downloads">
      The Bitbucket Cloud REST API (atlassian.com)</a> </li>
      <li>
      <a href="https://qiita.com/k-yamada-github/items/1c7422f1c2c0e2d6fdb9">
      bitbucketのAPIを使って、ダウンロードファイルの作成/取得を行う - Qiita</a> </li>
      <li>
      <a href="https://developer.atlassian.com/cloud/bitbucket/rest/api-group-downloads/#api-repositories-workspace-repo-slug-downloads-filename-get">
      The Bitbucket Cloud REST API (atlassian.com)</a> </li>
    </ul>
    <p>&nbsp;</p>
  </section>
    
  <p>&nbsp;</p>
  <hr>
  <p>&nbsp;</p>
    
  <section>
    <h2><a name="5._パイプライントリガー">5. パイプライントリガー</a></h2>
    <p>Pipelines のビルド構成は bitbucket-pipelines.yml ファイルで定義できます。Pipelines 
    を初めて利用される場合は、<a href="https://support.atlassian.com/ja/bitbucket-cloud/docs/get-started-with-bitbucket-pipelines/" target="_blank">Bitbucket 
    Pipelines を使い始める</a> のドキュメントをご確認ください。 </p>
    <p><img alt="パイプライントリガー" src="Pipelines_cpp/img45.jpg"></p>
    <p>&nbsp;</p>
    
    <h3><a name="5-1._手動でパイプラインを実行する">5-1. 手動でパイプラインを実行する</a></h3>
    <p>ブラウザ画面で Bitbucket のリポジトリを表示して、この画面から希望するブランチやコミットを対象にパイプライン実行することができます。</p>
    <p>&nbsp;</p>
    
    <h4>5-1-1. 手動実行のみ可能なパイプラインを設定する</h4>
    <p>パイプラインを手動でのみ実行したい場合、カスタム パイプラインを使用します。カスタム 
    パイプラインは、ブランチへのコミットでは自動的に実行されません。カスタム パイプラインを定義するには、bitbucket-pipelines.yml 
    ファイルの custom セクションにパイプライン構成を追加します。カスタム 
    パイプラインとして定義されていないパイプラインは、ブランチへのプッシュが発生したときに自動的に実行されます。 </p>
    <p>カスタム パイプラインのもう 1 つのメリットは、変数の値を一時的に追加または更新できる点です。バージョン番号を追加したり、1 
    回のみ使用する値を提供したりするために使用できます。詳細は 
    <a href="https://support.atlassian.com/ja/bitbucket-cloud/docs/pipeline-triggers/" target="_blank">
    パイプライン トリガー | Bitbucket Cloud | アトラシアン サポート (atlassian.com)</a> を参照してください。 
    </p>
    <p>パイプラインを手動で実行し、Bitbucket Cloud UI からトリガーするには、リポジトリへの書き込み権限が必要です。</p>
    <p>&nbsp;</p>
    <p>["bitbucket-pipelines.yml" 例]</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px;">
image: ubuntu:18.04

pipelines:
  <strong><span class="auto-style2">custom</span></strong>: # Pipelines that can only be triggered manually
    - step:
        name: Build
        script:
          - echo "This script can only be triggerd manually (custom)."
          - cat /etc/lsb-release
          - apt-get update
          - apt-get -y install build-essential
          - g++ hello.cpp -o hello
        artifacts:
          - hello</pre>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    
    <h4>5-1-2. ブランチとパイプランを選んで手動でパイプラインを実行する</h4>
    <p>ブラウザ画面から、ブランチとパイプランを選んで手動でパイプラインを実行する、手順を記載します。 </p>
    <p>下記のような bitbucket-pipelines.yml ファイルを登録している場合を例に説明します。 </p>
    <p>&nbsp;</p>
    <p>["bitbucket-pipelines.yml" 例]</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px;">
image: ubuntu:18.04

pipelines:
  default:
    - step:
        name: Build
        script:
          - cat /etc/lsb-release
          - apt-get update
          - apt-get -y install build-essential zip
          - g++ hello.cpp -o hello
        artifacts:
          - hello
    - step:
        name: Deploy
        script:
          - pwd &amp;&amp; ls -al
          - echo $BITBUCKET_CLONE_DIR
          - pipe: atlassian/bitbucket-upload-file:0.3.2
            variables:
              BITBUCKET_USERNAME: $BITBUCKET_USERNAME
              BITBUCKET_APP_PASSWORD: $BITBUCKET_APP_PASSWORD
              FILENAME: "${BITBUCKET_CLONE_DIR}/hello"

  <span class="auto-style2"><strong>custom</strong></span>: # Pipelines that can only be triggered manually
    custom-build:
      - step:
          script:
            - echo "This script can only be triggerd manually (custom)."
            - cat /etc/lsb-release
            - apt-get update
            - apt-get -y install build-essential
            - g++ hello.cpp -o hello
          artifacts:
            - hello</pre>
    <p>&nbsp;</p>
    
    <h5>方法１</h5>
    <p>(1) ［パイプライン］メニューを選択します。 </p>
    <p>(2) ［Run pipeline］ をクリックします。 </p>
    <p>
    <img alt="custom-build" class="border" src="Pipelines_cpp/img4E.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>(3) ”Branch” と ”Pipeline” を選択後、［Run］ボタンをクリックします。</p>
    <p><img alt="custom-build" src="Pipelines_cpp/img4F.jpg" width="600"></p>
    <p>&nbsp;</p>
    <p>以上の操作により、選択したブランチのコミット HEAD に対してパイプラインを実行します。 </p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    
    <h5>方法２</h5>
    <p>(1) ［ブランチ］メニューを選択します。</p>
    <p>&nbsp;(2) パイプランを実行するブランチの ［･･･］ &gt; ［Run pipelines for a branch］ をクリックします。</p>
    <p>
    <img alt="custom-build" class="border" src="Pipelines_cpp/img50.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>(3) ”Pipeline” を選択後、［Run］ボタンをクリックします。</p>
    <p><img alt="custom-build" src="Pipelines_cpp/img52.jpg" width="600"></p>
    <p>&nbsp;</p>
    <p>以上の操作により、選択したブランチのコミット HEAD に対してパイプラインを実行します。 </p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    
    <h4>5-1-3. 特定コミットをパイプライン実行する</h4>
    <p>以下の手順で行います。</p>
    <p>(1) ［コミット］メニューを選択します。 </p>
    <p>(2) パイプラインを実行するコミットを選択します。 </p>
    <p>
    <img alt="custom-build" class="border" src="Pipelines_cpp/img55.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>(3) 「Run pipeline」をクリックします。</p>
    <p>
    <img alt="custom-build" class="border" src="Pipelines_cpp/img57.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>(4) "Pipeline" を選択後、［Run］ボタンをクリックします。</p>
    <p><img alt="custom-build" src="Pipelines_cpp/img59.jpg" width="600"></p>
    <p>&nbsp;</p>
    <p>以上の操作により、コミットに対してパイプラインを実行します。</p>
    <p>&nbsp;</p>
  
    <div class="status_information">
      <div></div>
      <div>
        <p><strong>NOTE</strong></p>
        <p>当然のことですが、コミット時点の bitbucket-pipelines.yml ファイルに設定されている Pipelines 
        構成からのみ選択可能です。 </p>
      </div>
    </div>

    <p>&nbsp;</p>
    <p>&nbsp;</p>
    
    <h3><a name="5-2._特定ブランチへのコミットをトリガーにパイプラインを実行する">5-2. 特定ブランチへのコミットをトリガーにパイプラインを実行する</a></h3>
    <p>プッシュ先のブランチに応じてパイプラインの動作を変えることができます。これを行うには、bitbucket-pipelines.yml 
    ファイル内にブランチ固有の設定を含める必要があります。</p>
    <p>「<a href="https://ja.confluence.atlassian.com/bitbucket/configure-bitbucket-pipelines-yml-792298910.html" target="_blank">bitbucket-pipelines.yml 
    を設定する</a>」も参照してください。</p>
    <p>&nbsp;</p>
    <p>["bitbucket-pipelines.yml" 例] </p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px;">
image: ubuntu:18.04

pipelines:
  default:
    - step:
        script:
          - echo "This script runs on all branches that don't have any specific pipeline assigned in 'branches'."
  <strong><span class="auto-style2">branches</span></strong>:
    main:
      - step:
          name: Build
          script:
            - echo "This script runs only on commit to the main branch."
            - cat /etc/lsb-release
            - apt-get update
            - apt-get -y install build-essential
            - g++ hello.cpp -o hello
          artifacts:
            - hello
    feature/*:
      - step:
          script:
            - echo "This script runs only on commit to branches with names that match the feature/* pattern."</pre>
    <p>&nbsp;</p>
    <ul>
      <li><strong>main</strong> の定義は、main へのコミットで実行する命令を意味します。 </li>
      <li><strong>feature/*</strong>&nbsp;定義は、任意の <strong>feature</strong> 
      ブランチへのコミットで実行される命令を意味します。 </li>
      <li><strong>default</strong> の定義は、<strong>main</strong> または <strong>
      feature</strong> 以外の任意のブランチへのコミットで実行される命令を意味します。 </li>
    </ul>
    <p>&nbsp;</p>
    <p>以上の設定により、条件を満たすブランチへのコミットに対してパイプラインを実行します。 </p>
    <p>&nbsp;</p>
  
    <div class="status_information">
      <div></div>
      <div>
        <p><strong>NOTE</strong></p>
        <p>プルリクエストからのマージもコミットとして使われます。</p>
        <p>具体例として、例えば feature/add_function1 ブランチを develop ブランチへマージした場合は devekop 
        ブランチへのコミットとして扱われて該当するパイプラインがあれば実行されます。 </p>
      </div>
    </div>

    <p>&nbsp;</p>
  
    <div class="status_information">
      <div></div>
      <div>
        <p><strong>NOTE</strong></p>
        <p>複数のブランチ条件で同一の steps を実行する方法について下記で紹介されていました。 </p>
        <p>
        <a href="https://stackoverflow.com/questions/42304478/bitbucket-pipelines-multiple-branches-with-same-steps" target="_blank">
        git - Bitbucket Pipelines - multiple branches with same steps - Stack 
        Overflow</a> </p>
      </div>
    </div>

    <p>こんな感じで複数条件を記載すれば良いようです。</p>
    <p>注意事項として '{rev,staging}' 内にスペースを加えてはいけないと記載されていました。</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px;">
pipelines:
  branches:
    <span class="auto-style2"><strong>'{release/**,hotfix/**}'</strong></span>:
      - step:
        script:
          - echo 'step'</pre>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    
    <h3><a name="5-3._Pull_Request_をトリガーにパイプラインを実行する">5-3. "Pull Request" をトリガーにパイプラインを実行する</a></h3>
    <p>"Pull Request" をトリガーにパイプラインを実行する例について記載します。</p>
    <ul>
      <li>&nbsp;"bitbucket-pipelines.yml" で pull-requests 
      の中に記載するブランチ名は、プルリクエストする際の from 側のブランチ名です。</li>
      <li>プルリクエスト状態で新たにコミットを実施した場合、パイプライントリガーは pull-requests と branches 
      の両方を対象として実行されます。それぞれでパイプラインのトリガー条件を満足する場合は一回のコミットで２つのパイプラインを実行します。 </li>
      <li>pull-requests の条件で ‘**’ を設定した場合、下記例に示すように他で設定してしていないあらゆるブランチからの 
      pull-requests を対象とします。'**' と ‘*' は異なる意味を持ちます。’*' は ‘/' を含みませんが ‘**’ は '/’ 
      を含みます。</li>
    </ul>
    <p>&nbsp;</p>
    <p>["bitbucket-pipelines.yml" 例]</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px;">
image: ubuntu:18.04

pipelines:
  <strong><span class="auto-style2">pull-requests</span></strong>:
    '**':
      - step:
          script:
            - echo "This script runs on pull-requests to any branch not elsewhere defined."
    feature/*:
      - step:
          name: Build
          script:
            - echo "This script runs only on pull-requests to the main branch."
            - cat /etc/lsb-release
            - apt-get update
            - apt-get -y install build-essential
            - g++ hello.cpp -o hello
          artifacts:
            - hello</pre>
    <p>&nbsp;</p>
    <p>以上の操作により、条件を満足するブランチのプルリクエストおよびプルリクエスト中のコミットに対してパイプラインを実行します。</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    
    <h3><a name="5-4._スケジュールでパイプラインを実行する">5-4. スケジュールでパイプラインを実行する</a></h3>
    <p>
    スケジュールされたパイプラインを使用すると、パイプラインを時間、日、または週単位で実行できます。パイプラインを例えば毎晩０時に実行する、というスケジュールによるパイプライン実行はよく使用されるパイプライン運用方法の一つです。</p>
    <ul>
      <li>スケジュールされたパイプラインは、コミットや手動操作でトリガーされるあらゆるビルドに追加して実行できます。</li>
      <li>&nbsp;"bitbucket-pipelines.yml" ファイルで定義したすべてのパイプラインに対してスケジュールを作成できます。 
      </li>
      <li>カスタム パイプラインを作成した場合、それはスケジュールされたときまたは手動でトリガされたときにのみ実行されます。 </li>
    </ul>
    <p>&nbsp;</p>
    
    <h4>パイプラインのスケジュールを作成する</h4>
    <p>以下の手順でパイプラインのスケジュールを作成します。</p>
    <p>&nbsp;(1) Bitbucket のリポジトリに移動します。 </p>
    <p>(2) [<strong>パイプライン</strong>] &gt; [<strong>Schedules</strong>] (右上) 
    をクリックします。</p>
    <p>
    <img alt="pipelines - schedules" class="border" src="Pipelines_cpp/img76.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>(3) [New schedule] をクリックします。</p>
    <p>
    <img alt="pipelines - schedules" class="border" src="Pipelines_cpp/img77.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>(4) スケジュールを登録したいブランチとパイプラインを選択します。 </p>
    <ul>
      <li>スケジュール実行は、ブランチの HEAD コミットに対して実行します。 </li>
      <li>選択したブランチの bitbucket-pipelines.yml でパイプラインが定義されている必要があります。</li>
    </ul>
    <p>
    <img alt="pipelines - schedules" src="Pipelines_cpp/img79.jpg" width="600"></p>
    <p>
    &nbsp;</p>
    <p>
    (5) スケジュールを設定します。 </p>
    <ul>
      <li>パイプラインの実行間隔を選択します (時間、日、または週単位)。 </li>
      <li>ご利用のタイムゾーンで時間を選択します。パイプラインは UTC 時刻でスケジュールされます (夏時間の影響を受けません)。 </li>
      <li>
      スケジュールされたパイプラインは、選択した期間内の任意のタイミングで実行されます。これは、その期間にスケジュールされたパイプラインのトリガーを分散させるためです。 
      </li>
    </ul>
    <p>
    <img alt="pipelines - schedules" src="Pipelines_cpp/img7F.jpg" width="600"></p>
    <p>&nbsp;</p>
    <p>
    <img alt="pipelines - schedules" src="Pipelines_cpp/img80.jpg" width="600"></p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    
    <h4>スケジュールの削除</h4>
    <p>[パイプライン] &gt; [スケジュール] (画面右上の) に移動して、リポジトリのすべてのスケジュールを確認します。 </p>
    <ul>
      <li>スケジュールの右側にあるゴミ箱アイコンを使用してスケジュールを削除します。</li>
      <li>&nbsp;API を使用して作成されたスケジュールは、Cron 表現 (0 10 15 * *など) で表示されます。</li>
    </ul>
    <p>&nbsp;</p>
    <p><strong>参考：</strong></p>
    <ul>
      <li>
      <a href="https://support.atlassian.com/ja/bitbucket-cloud/docs/pipeline-triggers/">
      パイプライン トリガー | Bitbucket Cloud | アトラシアン サポート (atlassian.com)</a> </li>
      <li>
      <a href="https://support.atlassian.com/ja/bitbucket-cloud/docs/configure-bitbucket-pipelinesyml/">
      bitbucket-pipelines.yml を設定する | Bitbucket Cloud | アトラシアン サポート 
      (atlassian.com)</a> </li>
      <li>
      <a href="https://stackoverflow.com/questions/42304478/bitbucket-pipelines-multiple-branches-with-same-steps">
      git - Bitbucket Pipelines - multiple branches with same steps - Stack 
      Overflow</a> </li>
    </ul>
    <p>&nbsp;</p>
  </section>
    
  <p>&nbsp;</p>
  <hr>
  <p>&nbsp;</p>
  
  <section>
    <h2><a name="6._パイプラインで_git_clone_する">6. パイプラインで git clone する</a></h2>
    <h3><br>6-1. public リポジトリを git clone する</h3>
    <p>public リポジトリを “git clone“ する例として “google test“ のリポジトリを対象に git clone してみます。 </p>
    <p>下記にサンプルを記載します。</p>
    <p>&nbsp;</p>
    <p>["bitbucket-pipelines.yml" 例] </p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px;">
image: ubuntu:18.04

pipelines:
  default:
    - step:
        name: git clone
        script:
          - apt-get update &amp;&amp; apt-get -y install tzdata
          - export TZ="Asia/Tokyo" &amp;&amp; date
          - apt-get -y install git
          - git clone https://github.com/google/googletest.git
          - ls
          - cd googletest
          - ls</pre>
    <p>&nbsp;</p>
    <p>説明をかなり割愛しますが、public リポジトリはこんな感じで簡単に git clone できます。</p>
    <p>下図の通り、このパイプラインを全て正常に実行することができました。</p>
    <p>
    <img alt="Pipelines 中で git clone" class="border" src="Pipelines_cpp/img9.jpg" width="800"></p>
    <p>&nbsp;</p>
    
    <div class="status_warning">
      <div></div>
      <div>
        <p><strong>重要</strong></p>
        <p>上記例では、下記２行を入れることが正しく動作させるためのコツです。</p>
        <p>これら無しだと git インストール中に入力待ちとなって無限に Pipelines を終わらなくなるので注意してください。</p>
        <p>またこの状態になってしまったら <span class="auto-style3">手動で中止</span> 
        する必要があることも注意してください。 </p>
        <p><span class="cpp-source">- apt-get update &amp;&amp; apt-get -y install 
        tzdata</span> </p>
        <p><span class="cpp-source">- export TZ="Asia/Tokyo" &amp;&amp; date</span> </p>
      </div>
    </div>

    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <h3>6-2. 他の Bitbucket private リポジトリを git clone する</h3>
    <p>パイプラインの中で他の Bitbucket private リポジトリを git clone する手順について説明します。</p>
    <p>下記のようなことをすることを想定します。Hidetoshi_Kinoshita/pipelines_test1.git はこの評価のために私が準備した実験用の 
    private リポジトリです。</p>
    <p>&nbsp;</p>
    <p>["bitbucket-pipelines.yml" 例]</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px;">
image: ubuntu:18.04

pipelines:
  default:
    - step:
        name: git clone
        script:
          - apt-get update &amp;&amp; apt-get -y install tzdata
          - export TZ="Asia/Tokyo" &amp;&amp; date
          - apt-get -y install git
          - <span class="auto-style2">git clone git@bitbucket.org:Hidetoshi_Kinoshita/pipelines_test1.git</span>
          - ls
          - cd pp_pipelines_test1
          - ls</pre>
    <p>&nbsp;</p>
    <p>まずはこのままパイプラインを実行して結果を確認してみます。 </p>
    <p>&nbsp;</p>
    <p><img alt="実行結果" class="border" src="Pipelines_cpp/img13.jpg" width="800"></p>
    <p>&nbsp;</p>
    <p><img alt="実行結果" class="border" src="Pipelines_cpp/img14.gif" width="800"></p>
    <p>&nbsp;</p>
    <p>予想通りですが、「Permission denied (publickey) .」となって "git clone" 
    を失敗しました。パイプラインに対して SSH 鍵を登録してリポジトリへアクセスできるようにする必要がある、ということです。</p>
    <p>以下、パイプラインに対して SSH 鍵を登録する手順の説明です。</p>
    <p>&nbsp;</p>
    <p>(1) パイプラインを実行する側のリポジトリ設定から「SSH keys」メニューをクリックします。</p>
    <p>&nbsp;</p>
    <p>(2) [Generate keys] または [Use my own keys] ボタンをクリックします。</p>
    <p>ここでは [Generate keys] ボタンをクリックして進みます。</p>
    <p>
    <img alt="Generate keys" class="border" src="Pipelines_cpp/img19.jpg" width="800"></p>
    <p>&nbsp;</p>
    <p>(3) "Private key" と "Public key" を生成して下図のような画面へ表示します。</p>
    <p>
    <img alt="SSH keys" src="Pipelines_cpp/img1A.jpg" class="border" width="800"></p>
    <p>&nbsp;</p>
    <p>(4) [<strong>Copy public key</strong>] ボタンをクリックして ”public key” をコピーします。</p>
    <p>
    <img alt="SSH keys" class="border" src="Pipelines_cpp/img1E.jpg" width="800"></p>
    <p>&nbsp;</p>
    <p>(5) ターゲットリポジトリへ “public key“ 
    を登録します。リポジトリ("pipelines_test1")へ移動して、[Repository settings] &gt; [一般] &gt; [アクセスキー] 
    をクリックします。 </p>
    <p>
    <img alt="SSH keys" class="border" src="Pipelines_cpp/img20.jpg" width="800"></p>
    <p>&nbsp;</p>
    <p>(6) [Add key] ボタンをクリックします。</p>
    <p>
    <img alt="SSH keys" class="border" src="Pipelines_cpp/img23.jpg" width="800"></p>
    <p>&nbsp;</p>
    <p>(7) 下図のような画面を表示するので、必要事項を記入後に [Add SSH key] ボタンをクリックします。 </p>
    <ul>
      <li>Label : 後で何の鍵かを特定できる名前を付けましょう </li>
      <li>Key : (4) でコピーした公開鍵をここに貼ります</li>
    </ul>
    <p><img alt="SSH keys" src="Pipelines_cpp/img26.jpg" width="800"></p>
    <p>&nbsp;</p>
    <p>ここでは下図のように入力してみました。[Add SSH key] ボタンをクリックします。</p>
    <p><img alt="SSH keys" src="Pipelines_cpp/img27.jpg" width="800"></p>
    <p>&nbsp;</p>
    <p>するとこんな感じの画面表示となりました。</p>
    <p>
    <img alt="SSH keys" class="border" src="Pipelines_cpp/img2A.jpg" width="800"></p>
    <p>&nbsp;</p>
    <p>以上で SSH 鍵の設定を完了です。</p>
    <p>&nbsp;</p>
    <p>(8) 先程失敗（Failed）となったパイプラインを再度実行してみます。</p>
    <p>[Run pipelines] ボタンをクリックします。</p>
    <p>
    <img alt="Run pipeline" src="Pipelines_cpp/img2D.jpg" class="border" width="800"></p>
    <p>
    &nbsp;</p>
    <p>
    下図画面を表示するので［Run］ボタンをクリックします。</p>
    <p>
    <img alt="Run pipeline" src="Pipelines_cpp/img32.jpg" width="800"></p>
    <p>
    &nbsp;</p>
    <p>
    <img alt="Run pipeline" class="border" src="Pipelines_cpp/img33.jpg" width="800"></p>
    <p>
    &nbsp;</p>
    <p>
    パイプライン実行を成功です。</p>
    <p>
    以上の手順により、他の Bitbucket private リポジトリから git clone できることを確認できました。 </p>
    <p>
    &nbsp;</p>
    <p>
    <strong>参考：</strong></p>
    <ul>
      <li>
      <a href="https://bitbucket.org/blog/cloning-another-bitbucket-repository-in-bitbucket-pipelines" target="_blank">
      Cloning another Bitbucket repository in Bitbucket Pipelines - Bitbucket</a></li>
    </ul>
  </section>

  <p>&nbsp;</p>
  <hr>
  <p>&nbsp;</p>
    
  <section>
    <h2><a name="7._アーティファクトのファイル名にビルド番号を付ける">7. アーティファクトのファイル名にビルド番号を付ける</a></h2>
    <p>変数 <strong>BITBUCKET_BUILD_NUMBER</strong> 
    によりパイプライン中でビルド番号を使うことができます。これを使うことでパイプラインを実行する度にファイル名やフォルダ名を変えることが可能になります。</p>
    <p>&nbsp;</p>
    <p>["bitbucket-pipelines.yml" 例]</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px;">
image: ubuntu:18.04

pipelines:
  default:
    - step:
        name: Build
        script:
          - cat /etc/lsb-release
          - apt-get update
          - apt-get -y install build-essential
          - mkdir out
          - g++ hello.cpp -o out/hello_$BITBUCKET_BUILD_NUMBER
          - ls out
        artifacts:
          - out/**</pre>
    <p>&nbsp;</p>
    <p>これを実行することで <strong>hello_6</strong> というファイルを出力することができました。<strong>6</strong> 
    という値はビルド番号 <strong>#6</strong> からくるものです。</p>
    <p>
    <img alt="BITBUCKET_BUILD_NUMBER 使用方法" class="border" src="Pipelines_cpp/img36.jpg" width="800"></p>
    <p>&nbsp;</p>
  
    <div class="status_information">
      <div></div>
      <div>
        <p><strong>NOTE</strong></p>
        <p>'artifacts' で <span class="cpp-source">$BITBUCKET_BUILD_NUMBER</span> 
        を使うことはできないように見えます。</p>
        <p>下記のようなサンプルで実験しましたが、 <span class="cpp-source">
        out_$BITBUCKET_BUILD_NUMBER/**</span> を artifacts へ登録できませんでした。'script' 
        を全て正常に動作できていることから、 artifacts 固有の問題と推測しています。 </p>
      </div>
    </div>

    <p>&nbsp;</p>
    <p>["bitbucket-pipelines.yml" 例]</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px;">
image: ubuntu:18.04

pipelines:
  default:
    - step:
        name: Build
        script:
          - cat /etc/lsb-release
          - apt-get update
          - apt-get -y install build-essential zip
          - mkdir out
          - mkdir out_$BITBUCKET_BUILD_NUMBER
          - g++ hello.cpp -o out/hello_$BITBUCKET_BUILD_NUMBER
          - cp out/hello_$BITBUCKET_BUILD_NUMBER out_$BITBUCKET_BUILD_NUMBER/hello_$BITBUCKET_BUILD_NUMBER
          - ls out
          - ls out_$BITBUCKET_BUILD_NUMBER
        artifacts:
          - out/**
          - <span class="auto-style2">out_$BITBUCKET_BUILD_NUMBER/**</span></pre>
    <p>&nbsp;</p>
    <p><strong>参考：</strong></p>
    <ul>
      <li>
      <a href="https://ja.confluence.atlassian.com/bitbucket/variables-in-pipelines-794502608.html" target="_blank">
      Variables in pipelines | Bitbucket Cloud | Atlassian Documentation</a></li>
    </ul>
  </section>
    
  <p>&nbsp;</p>
  <hr>
  <p>&nbsp;</p>
  
  <section>
    <h2><a name="8._ユニットテストを行う">8. ユニットテストを行う</a></h2>
    <p>Pipelines 上でユニットテストを実施します。</p>
    <p>cmake でユニットテストを構成済みであることを前提として以下を記載します。</p>
    <p>&nbsp;</p>
    <ul>
      <li>ユニットテストの実施は、下記で行っています。<br><span class="cpp-source">ctest 
      --output-on-failure</span> </li>
      <li>この例では、ユニットテストを googletest により実施しています。<br>googletest 
      をサイトから取得したソース一式（release-1.12.0.tar.gz）をリポジトリへ保存しておき、pipelines 
      によりビルド＆インストールしています。<br>"apt-get install" 
      などを使ってインストールしても良いのですが、バージョンアップに伴う仕様変更を懸念して常に同一のソフトを使う、という例とさせていただきました。 
      </li>
      <li>ユニットテスト実装および詳細については、本ページでは説明を割愛します。</li>
      <li>cmake および ctest などについては、本ページでは説明を割愛します。インターネット上の記事などで学習してください。 </li>
    </ul>
    <p>&nbsp;</p>
    <p>["bitbucket-pipelines.yml" 例]</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px;">
image: ubuntu:22.04

pipelines:
  default:
    - parallel:
      - step:
          name: build and unit-test
          script:
            - apt-get update &amp;&amp; apt-get -y install tzdata
            - export TZ="Asia/Tokyo" &amp;&amp; date
            - apt-get -y install build-essential cmake
            - gcc --version &amp;&amp; cmake --version &amp;&amp; lcov --version &amp;&amp; cppcheck --version
            # build and install googletest.
            - tar zxvf release-1.12.0.tar.gz   &nbsp;# googletest
            - cd googletest-release-1.12.0
            - mkdir build
            - cd build
            - cmake ..
            - make
            - make install
            - cd ..
            - cd ..
            # build and tests.
            - mkdir build
            - cd build
            - cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON ..
            - make
            # do unit-tests.
            - ctest --output-on-failure</pre>
    <p>&nbsp;</p>
    <p>以下、CMakeLists.txt の部分の身参考記載します。</p>
    <p>[(参考) "CMakeLists.txt" 例]</p>
    <pre class="prettyprint linenums" style="width: 800px;">
# このバージョン以上のCMAKEを使うよう宣言
cmake_minimum_required(VERSION 3.10)

# プロジェクト名．c/c++言語であることを宣言
#project(sample CXX)
project(sample C)

# バージョン番号
set(serial "1.0.0")

# c++17 が必要
set(CMAKE_CXX_STANDARD 17)

# デバッグ出力
message(STATUS "PROJECT_SOURCE_DIR = ${PROJECT_SOURCE_DIR}")
message(STATUS "PROJECT_BINARY_DIR = ${PROJECT_BINARY_DIR}")
message(STATUS "CMAKE_CXX_STANDARD = ${CMAKE_CXX_STANDARD}")

# 共通オプション
set(CMAKE_CXX_FLAGS "--coverage")
set(CMAKE_C_FLAGS "--coverage")
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} --coverage")

# ビルドの種類によってオプションを変える
set(CMAKE_CXX_FLAGS_DEBUG "-Wall -O0 -g")
set(CMAKE_CXX_FLAGS_RELEASE "-Wall -O3 -DNDEBUG")
set(CMAKE_CXX_FLAGS_MINSIZEREL "-Wall -Os -DNDEBUG")
set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "-Wall -O2 -g -DNDEBUG")
set(CMAKE_C_FLAGS_DEBUG "-Wall -O0 -g")
set(CMAKE_C_FLAGS_RELEASE "-Wall -O3 -DNDEBUG")
set(CMAKE_C_FLAGS_MINSIZEREL "-Wall -Os -DNDEBUG")
set(CMAKE_C_FLAGS_RELWITHDEBINFO "-Wall -O2 -g -DNDEBUG")

include_directories(include)

add_subdirectory(PfLogPrintf)

# ライブラリの作成を指示．SHARED で共有ライブラリ
# sample.c を元に、libsample.so という名前で作成
add_library(sample SHARED sample.c)

# sample.so をビルドする際に PfLogPrintf をリンクする
target_link_libraries(sample PfLogPrintf)

if(BUILD_TESTING)
  # ctest を valgrind ありで実行するために下記が必要
  include(CTest)

  # テストを有効化
  enable_testing()
  # サブディレクトリを指定．指定したディレクトリ内のCMakeLists.txt が実行される
  add_subdirectory(test)
endif()

# capability ライブラリのインクルードディレクトリを教えてあげる
# PROJECT_SOURCE_DIRはこのプロジェクトのルートディレクトリの絶対パス
target_include_directories( sample
  PUBLIC ${PROJECT_SOURCE_DIR}/include
  )</pre>
    <p>&nbsp;</p>
    <p>[(参考) test フォルダ内の "CMakeLists.txt" 例]</p>
    <pre class="prettyprint linenums" style="width: 800px;">
# このバージョン以上のCMAKEを使うよう宣言
cmake_minimum_required(VERSION 3.10)

# プロジェクト名．c/c++言語であることを宣言
project(test_sample CXX)
#project(test_sample C)

# To use the googletest
find_package(GTest REQUIRED)

# デバッグ出力
message(STATUS "PROJECT_SOURCE_DIR = ${PROJECT_SOURCE_DIR}")
message(STATUS "PROJECT_BINARY_DIR = ${PROJECT_BINARY_DIR}")
message(STATUS "CMAKE_CXX_STANDARD = ${CMAKE_CXX_STANDARD}")

# 共通オプション
set(CMAKE_CXX_FLAGS "--coverage")
set(CMAKE_C_FLAGS "--coverage")
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} --coverage")

# ビルドの種類によってオプションを変える
set(CMAKE_CXX_FLAGS_DEBUG "-Wall -O0 -g")
set(CMAKE_CXX_FLAGS_RELEASE "-Wall -O3 -DNDEBUG")
set(CMAKE_CXX_FLAGS_MINSIZEREL "-Wall -Os -DNDEBUG")
set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "-Wall -O2 -g -DNDEBUG")

# リンクディレクトリの指定
#link_directories(PfLogPrintf)

# 今回作成する実行ファイル test_sample, ソースファイル３つ
add_executable(
    test_sample
    function1_test.cpp
    function2_test.cpp
    function3_test.cpp
    )
 
# gtest, pthread をリンクします
target_link_libraries(
    test_sample 
    ${GTEST_BOTH_LIBRARIES} 
    pthread
    sample)

#target_link_libraries(test_sample GTest::GTest GTest::Main)
target_include_directories(test_sample PUBLIC ${GTEST_INCLUDE_DIRS})

include(GoogleTest)
gtest_add_tests(TARGET test_sample)</pre>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
  </section>
 
  <p>&nbsp;</p>
  <hr>
  <p>&nbsp;</p>

  <section>
    <h2><a name="9._ユニットテストへ動的解析を加える_(Valgrind)">9. ユニットテストへ動的解析を加える (<em>Valgrind</em>)</a></h2>
    <p><strong><em>Valgrind</em></strong>（ヴァルグリンド）は、メモリデバッグや、メモリリークの検出、スレッドエラーの検出、プロファイリングなどを行うための仮想機械を利用したソフトウェア開発ツールです。</p>
    <p>ユニットテストと <strong><em>Valgrind</em></strong> を併用するのはとても有益で良い方法の１つです。</p>
    <p><strong><em>Valgrind</em></strong> で最もよく利用されている標準のツールは <strong><em>
    Memcheck</em></strong> です。 <strong><em>Memcheck</em></strong> 
    はほぼすべての命令に特別な計測用のコードを挿入し、「正当性」があり、「アドレス可能」であるかという情報が、それぞれVビットおよびAビットに格納されているかを追跡します。データは移動したり加工されたりするが、計測用のコードは1ビットレベルで正確であるようにA、Vビットを追跡します。</p>
    <p>さらに、<strong><em>Memcheck</em></strong> 
    は標準のCメモリアロケータを独自の実装に置き換え、割り当て済みブロックの前後にメモリガードを挿入します。この機能により、<strong><em>Memcheck</em></strong> 
    はプログラムが割り当てられたブロックよりわずかに外側の領域を読み書きする off-by-one エラーを検出できます。</p>
    <p><strong><em>Memcheck</em></strong> が検出や警告可能な問題には、下記のものがあります。</p>
    <ul>
      <li>初期化されていないメモリの使用 </li>
      <li>free されたメモリの読み書き </li>
      <li>malloc されたブロックの終端以降への読み書き </li>
      <li>メモリリーク </li>
    </ul>
    <p>
    こうした機能への代償として処理性能が低下します。Memcheckの元で動作するプログラムはValgrindなしで動作する場合と比べて5倍から20倍遅く、また多くのメモリを使用します。（メモリ確保ごとにかなりのメモリを追加で消費します）。したがって、ほとんどの開発者は常にMemcheck（あるいは他のValgrindツール）の元でコードを走らせることはしません。特定のバグを解析したり、（Memcheckが検出可能な種類の）潜在的なバグがないことを検証するために使用するのが最も典型的な方法です。</p>
    <p>&nbsp;</p>
    <p>ユニットテストの実行を <strong><em>Valgrind</em></strong> で実施する手順を以下に記載します。ここでは 
    <strong><em>ctest</em></strong> のオプション指定を変更することで実施する例を示します。（<strong><em>ctest</em></strong> 
    は標準で <strong><em>Valgrind</em></strong> をサポートしています。）</p>
    <p>&nbsp;</p>
    <ol>
      <li>apt-get install で <strong><em>Valgrind</em></strong> を追加します。<br>
      <span class="cpp-source">apt-get install -y valgrind</span></li>
      <li>前述のユニットテストを下記の通り変更します。<br>(新) <span class="cpp-source">ctest 
      --output-on-failure -T MemCheck --overwrite 
      MemoryCheckCommandOptions="--leak-check=full --error-exitcode=1"</span><br>
      (旧) <span class="cpp-source">ctest --output-on-failure</span></li>
    </ol>
    <p>&nbsp;</p>
    <p>["bitbucket-pipelines.yml" 例]</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px;">
image: ubuntu:22.04

pipelines:
  default:
    - parallel:
      - step:
          name: build and unit-test, coverage
          script:
            - apt-get update &amp;&amp; apt-get -y install tzdata
            - export TZ="Asia/Tokyo" &amp;&amp; date
            - apt-get -y install build-essential cmake valgrind lcov cppcheck zip
            - gcc --version &amp;&amp; cmake --version &amp;&amp; lcov --version &amp;&amp; cppcheck --version
            # build and install googletest.
            - tar zxvf release-1.12.0.tar.gz   &nbsp;# googletest
            - cd googletest-release-1.12.0
            - mkdir build
            - cd build
            - cmake ..
            - make
            - make install
            - cd ..
            - cd ..
            # build IoGeneral and tests.
            - mkdir build
            - cd build
            - cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON <span class="auto-style2">-DBUILD_TESTING=ON</span> ..
            - make
            # do unit-tests.
            - ctest --output-on-failure <span class="auto-style2">-T MemCheck --overwrite MemoryCheckCommandOptions="--leak-check=full --error-exitcode=1"</span></pre>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
  </section>
    
  <p>&nbsp;</p>
  <hr>
  <p>&nbsp;</p>

  <section>
    <h2><a name="10._ユニットテストへソースコードカバレッジを加える">10. ユニットテストへソースコードカバレッジを加える</a></h2>
    <p>ソースコードカバレッジ処理を追加する例を以下に記載します。</p>
    <ul>
      <li>gcc/g++ ビルド時に "-coverage" オプションを付けています。詳細説明割愛。</li>
      <li>lcov というツールによりユニットテストを実行した結果のソースコードカバレッジを可視化（html）しています。</li>
    </ul>
    <p>&nbsp;</p>
    <p>["bitbucket-pipelines.yml" 例]</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px;">
image: ubuntu:22.04

pipelines:
  default:
    - parallel:
      - step:
          name: build and unit-test, coverage
          script:
            - apt-get update &amp;&amp; apt-get -y install tzdata
            - export TZ="Asia/Tokyo" &amp;&amp; date
            - apt-get -y install build-essential cmake valgrind lcov cppcheck zip
            - gcc --version &amp;&amp; cmake --version &amp;&amp; lcov --version &amp;&amp; cppcheck --version
            # build and install googletest.
            - tar zxvf release-1.12.0.tar.gz   &nbsp;# googletest
            - cd googletest-release-1.12.0
            - mkdir build
            - cd build
            - cmake ..
            - make
            - make install
            - cd ..
            - cd ..
            # build sample and tests.
            - mkdir build
            - cd build
            - cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON ..
            - make
            # do unit-tests.
            - ctest --output-on-failure
          after-script:
            # source code coverage &lt;-
            - pwd &amp;&amp; ls
            - pushd build/CMakeFiles/sample.dir
            - lcov -d . -c -o sample.info --rc lcov_branch_coverage=1
            - lcov -r sample.info */googletest/* test/* */c++/* -o sampleFiltered.info --rc lcov_branch_coverage=1
            - genhtml -o lcovHtml --num-spaces 4 -s --legend sampleFiltered.info --branch-coverage
            - popd
            # -&gt;
            # deploy results of source code coverage.
            - echo $BITBUCKET_CLONE_DIR
            - zip -r lcovHtml_IoGeneral.zip build/CMakeFiles/sample.dir/lcovHtml
            - pipe: atlassian/bitbucket-upload-file:0.3.2
              variables:
                BITBUCKET_USERNAME: $BITBUCKET_USERNAME
                BITBUCKET_APP_PASSWORD: $BITBUCKET_APP_PASSWORD
                FILENAME: "${BITBUCKET_CLONE_DIR}/lcovHtml_sample.zip"
            # -&gt;

          artifacts:
            - build/CMakeFiles/sample.dir/lcovHtml/**</pre>
    <p>&nbsp;</p>
    <p>ソースコードカバレッジ測定の主たる実行部分は下記３行です。</p>
    <pre class="prettyprint linenums:34 lang-yml" style="width: 800px;">
            - lcov -d . -c -o sample.info --rc lcov_branch_coverage=1
            - lcov -r sample.info */googletest/* test/* */c++/* -o sampleFiltered.info --rc lcov_branch_coverage=1
            - genhtml -o lcovHtml --num-spaces 4 -s --legend sampleFiltered.info --branch-coverage</pre>
    <p>&nbsp;</p>
    <ul>
      <li>下記処理により、ソースコードカバレッジの結果から googletest/, test/, c++/ を除外するように指定しています。<br>
        <p><span class="cpp-source">- lcov -r sample.info */googletest/* test/* 
        */c++/* -o sample.info --rc lcov_branch_coverage=1</span></p>
      </li>
      <li>上記例では、カバレッジ計測結果をアーティファクトへ登録、ダウンロードへ登録、を行っています。</li>
    </ul>
    <p>&nbsp;</p>
    <p>以上の処理により下図のような結果を取得することができます。</p>
    <p>
    <img alt="カバレッジ結果" class="border" src="Pipelines_cpp/img73.jpg" width="1000"></p>
    <p>&nbsp;</p>
    <p>
    <img alt="カバレッジ結果" class="border" src="Pipelines_cpp/img78.jpg" width="1000"></p>
    <p>&nbsp;</p>
  </section>

  <p>&nbsp;</p>
  <hr>
  <p>&nbsp;</p>
  
  <section>
    <h2><a name="11._静的解析を行う_(cppcheck)">11. 静的解析を行う (<em>cppcheck</em>)</a></h2>
    <p>オープンソースの静的解析ツール（<strong><em>cppcheck</em></strong>）を pipelines 
    中で適用する例を紹介します。</p>
    <ul>
      <li>"apt-get -y install cppcheck" で <strong><em>cppcheck</em></strong> 
      をインストールしています。</li>
      <li><span class="cpp-source">cppcheck --project=compile_commands.json 
      --enable=all --error-exitcode=1 --inline-suppr --force 
      --suppressions-list=../suppressions_list.txt -i$BITBUCKET_CLONE_DIR/test/</span> 
      で <strong><em>cppcheck</em></strong> を実施しています。 </li>
      <li><strong><em>cppcheck</em></strong> を適用するソースファイルは cmake により <strong>
      compile_commands.json</strong> というファイルを出力してこれを使用しています。</li>
      <li>&nbsp;"-i" により静的解析の対象から除外する対象を指定できます。<br>例では <span class="cpp-source">
      -i$BITBUCKET_CLONE_DIR/test/</span> という記載により "test/" 
      フォルダを静的解析の対象から除外しています。<br>いろいろ実験してみましたが、フルパス表記で指定する必要がありそうです。このため <strong>
      $BITBUCKET_CLONE_DIR</strong> という環境変数を使用しています。 </li>
    </ul>
    <p>&nbsp;</p>
    <p>["bitbucket-pipelines.yml" 例]</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px;">
image: ubuntu:22.04

pipelines:
  default:
    - parallel:           
      - step:
          name: cppcheck
          script:
            - apt-get update &amp;&amp; apt-get -y install tzdata
            - export TZ="Asia/Tokyo" &amp;&amp; date
            - apt-get -y install build-essential cmake valgrind lcov cppcheck
            - cppcheck --version
            # build and install googletest.
            - tar zxvf release-1.12.0.tar.gz   &nbsp;# googletest
            - cd googletest-release-1.12.0
            - mkdir build
            - cd build
            - cmake ..
            - make
            - make install
            - cd ..
            - cd ..
            # build sample
            - mkdir build
            - cd build
            - cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON ..
            # cppcheck
            - cppcheck --project=compile_commands.json --enable=all --error-exitcode=1 --inline-suppr --force --suppressions-list=../suppressions_list.txt -i$BITBUCKET_CLONE_DIR/test/</pre>
    <p>&nbsp;</p>
  </section>
    
  <p>&nbsp;</p>
  <hr>
  <p>&nbsp;</p>

  <section>
    <h2><a name="Appendix">Appendix</a></h2>
    <p>&nbsp;</p>
    <h3><a name="A.1._Pipelines_の_step_における失敗によるスクリプト停止を避ける方法">A.1. Pipelines の step における失敗によるスクリプト停止を避ける方法</a></h3>
    <p>Pipelines は Linux 上でbash / 
    shellコマンドを実行しているだけです。スクリプトランナーは、各コマンドの戻り状況コードを探して成功したか失敗したかを確認します。したがって、さまざまな手法を使用してこのステータスコードを制御できます。</p>
    <p>&nbsp;</p>
    <h5>方法１</h5>
    <p>あなたのコマンドの末尾に " || true" を加える、という方法があります。</p>
    <p>(例) <span class="cpp-source">./gradlew -DBASE_URL=qa2 clean BSchrome_win 
    || true</span> </p>
    <p>&nbsp;</p>
    <h5>方法２</h5>
    <p>必ず実行したいステップを after-script へ記載すると、前のステップの成功/失敗ステータスに関係なく常に実行することができます。</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px;">
- step:
    name: Hoge
    script:
      - 何か処理する
      - 何か処理する
    after-script:
      - cd config/geb # You may need this, if the current working directory is reset. Check with 'pwd'
      - cd build/reports
      - zip -r testresult.zip BSchrome_winTest </pre>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <h3>&nbsp;</h3>
    <h3><a name="A.2._Pipelines_最長実行時間を変更する方法">A.2. Pipelines 最長実行時間を変更する方法</a></h3>
    <p>Pipelines は step １つに対して最長 120分 を実行することができます。max-time 
    を設定することでこの値を変更することができ、(1-120) の範囲でこの値を変更可能です。</p>
    <p>&nbsp;</p>
    <pre class="prettyprint linenums lang-yml" style="width: 800px;">
options:  
   max-time: 60</pre>
    <p>&nbsp;</p>
    <ul>
      <li><strong><em>max-time</em></strong> 無指定時のデフォルト値は 120分 です。</li>
      <li><strong><em>max-time</em></strong> について詳しくはドキュメント 
      <a href="https://support.atlassian.com/ja/bitbucket-cloud/docs/global-options/#Max-time" target="_blank">
      グローバル オプション | Bitbucket Cloud | アトラシアン サポート</a> を参照ください。 </li>
    </ul>
  </section>
              
  <p>&nbsp;</p>
  <hr>
  <p>&nbsp;</p>
	
<p>&nbsp;</p>
<p>&nbsp;</p>

  <section>
    <h2><a id="ライセンス">ライセンス</a></h2>
    <p>本ページの情報は、特記無い限り下記 MIT ライセンスで提供されます。</p>
    <div class="license">
      The MIT License (MIT)<br><br>
      
      &nbsp; Copyright 2021 Kinoshita Hidetoshi<br><br>
      
      Permission is hereby granted, free of charge, to any person obtaining a copy
      of this software and associated documentation files (the "Software"), to deal
      in the Software without restriction, including without limitation the rights
      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      copies of the Software, and to permit persons to whom the Software is
      furnished to do so, subject to the following conditions:<br><br>
      
      The above copyright notice and this permission notice shall be included in all
      copies or substantial portions of the Software.<br><br>
      
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      SOFTWARE.
    </div>
    <p>&nbsp;</p>
  </section>
  
  <p> &nbsp;</p>
  
  <section>
  	<h2><a id="参考">参考</a></h2>
	<ul>
		<li>
        <a href="https://support.atlassian.com/ja/bitbucket-cloud/resources/" target="_blank">
        Bitbucket Cloud リソース | Bitbucket Cloud | アトラシアン サポート (atlassian.com)</a></li>
        <li>
        <a href="https://ja.confluence.atlassian.com/bitbucket/configure-bitbucket-pipelines-yml-792298910.html" target="_blank">
        Configure bitbucket-pipelines.yml | Bitbucket Cloud | Atlassian 
        Documentation</a></li>
        <li>
        <a href="https://www.lyzon.co.jp/blog/2021/20210105_bitbucketpipelines/" target="_blank">
        Bitbucket PipelinesでCI/CD入門！ビルドとレンタルサーバーへのFTPデプロイを自動化する (lyzon.co.jp)</a></li>
        <li>
        <a href="https://github.com/tdlib/td/blob/master/bitbucket-pipelines.yml" target="_blank">
        td/bitbucket-pipelines.yml at master · tdlib/td (github.com)</a></li>
        <li>
        <a href="https://github.com/ignitionrobotics/ign-plugin/blob/ign-plugin1/bitbucket-pipelines.yml" target="_blank">
        ign-plugin/bitbucket-pipelines.yml at ign-plugin1 · 
        ignitionrobotics/ign-plugin (github.com)</a></li>
        <li>
        <a href="https://qiita.com/keisuke-nakata/items/cb3d436519dab2868c39" target="_blank">
        Bitbucket Pipelines の cache の使い方 - Qiita</a></li>
	</ul>
  </section>
  
  <p>&nbsp;</p>
  <hr>
  <p>&nbsp;</p>
  
  <section>
  	<h2 style="margin-bottom:5px">変更履歴</h2>
  	<table>
  	  <tr>
  	    <td class="td_history_date">2021-04-10</td>
  	    <td class="td_history_separator">-</td>
  	    <td class="td_history">新規作成 </td>
  	  </tr>
  	</table>
  
  <p>&nbsp;</p>
  
  <section>
    <p><a href="../../index.html" target="_parent">Programming Items トップページ</a></p>
    <p><a href="../../privacy_policy.html">プライバシーポリシー</a></p>
  </section>
  
  <p>&nbsp;</p>
  
  <footer>
  	<p><small>&copy; 2021 Kinoshita Hidetoshi (木下英俊)</small></p>
  </footer>

</body>
</html>
